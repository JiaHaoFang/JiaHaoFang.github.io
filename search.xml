<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo 相关记录</title>
    <url>/Hexo%20%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="使用git分支保存源码"><a class="markdownIt-Anchor" href="#使用git分支保存源码"></a> 使用git分支保存源码</h2>
<ol>
<li>
<p>拉取分支</p>
<p>因Github Page要求使用master分支作为发布网站的源代码，我们只能用master分支来保存hexo生成的静态网页，对于博客源码，可以新建一个source分支来存储。在github上打开Pages对应的仓库，也就是以”<a href="http://username.github.io/">username.github.io</a>”命名的仓库，然后建立一个source分支，仓库的默认分支改为保存源码的source分支，这样通过<code>git clone</code>拉取的就是source分支代码了。</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone &lt;https://github.com/JiaHaoFang/JiaHaoFang.github.io.git&gt;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>配置环境</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装hexo</span></span><br><span class="line">npm install hexo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git支持</span></span><br><span class="line">npm install hexo-deployer-git -save</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="添加next主题配置"><a class="markdownIt-Anchor" href="#添加next主题配置"></a> 添加next主题配置</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone &lt;https://github.com/theme-next/hexo-theme-next.git&gt; themes/next</span><br></pre></td></tr></table></figure>
<h2 id="显示摘要"><a class="markdownIt-Anchor" href="#显示摘要"></a> 显示摘要</h2>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line"># 显示摘要</span><br><span class="line">npm install hexo-excerpt --save</span><br></pre></td></tr></table></figure>
<h2 id="用typora写作"><a class="markdownIt-Anchor" href="#用typora写作"></a> 用typora写作</h2>
<h3 id="markdown语法支持"><a class="markdownIt-Anchor" href="#markdown语法支持"></a> markdown语法支持</h3>
<p>使用typora作为语法编辑器，使用插件使网页能够支持markdown的编辑格式</p>
<ol>
<li>
<p>安装库</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">markdown语法支持</span></span><br><span class="line">npm uni hexo-renderer-marked --save</span><br><span class="line">npm i @upupming/hexo-renderer-markdown-it-plus --save</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用<br />
在hexo站点配置文件_config.yml中添加如下配置，<a href="https://github.com/CHENXCHEN/hexo-renderer-markdown-it-plus">详细配置</a>:</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Markdown config</span></span><br><span class="line"><span class="attr">markdown_it_plus:</span></span><br><span class="line">	<span class="attr">highlight:</span> <span class="literal">true</span></span><br><span class="line">	<span class="attr">html:</span> <span class="literal">true</span></span><br><span class="line">	<span class="attr">xhtmlOut:</span> <span class="literal">true</span></span><br><span class="line">	<span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">	<span class="attr">langPrefix:</span></span><br><span class="line">	<span class="attr">linkify:</span> <span class="literal">true</span></span><br><span class="line">	<span class="attr">typographer:</span></span><br><span class="line">	<span class="attr">quotes:</span> <span class="string">“”‘’</span></span><br><span class="line">	<span class="attr">pre_class:</span> <span class="string">highlight</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="图片链接"><a class="markdownIt-Anchor" href="#图片链接"></a> 图片链接</h3>
<p>为了与typora写作，使网页能够直接渲染typora编辑的markdown文档，需要在typora中设置图片保存在./$${filename}下，安装该插件即可（该插件md写着是为了与typora共同使用而开发）</p>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line"># 图片链接</span><br><span class="line">npm install hexo-image-link --save</span><br></pre></td></tr></table></figure>
<h2 id="文章置顶"><a class="markdownIt-Anchor" href="#文章置顶"></a> 文章置顶</h2>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line"># 添加文章置顶功能，未使用</span><br><span class="line">npm uninstall hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure>
<p>安装后在文章顶部增加字段<code>top: true</code>即可</p>
<h2 id="页脚增加网站运行时间统计next80-以下"><a class="markdownIt-Anchor" href="#页脚增加网站运行时间统计next80-以下"></a> 页脚增加网站运行时间统计(NexT8.0 以下)</h2>
<ol>
<li>
<p>找到 <code>\\themes\\next\\layout\\_partials\\</code> 下面的 <code>footer.swig</code> 文件</p>
</li>
<li>
<p>在合适的位置添加下面代码（通过运行调试，查看运行时间出现的位置）（45行）</p>
 <figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;!--添加运行时间--&gt;</span><br><span class="line">&lt;span id=&quot;sitetime&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;script language=javascript&gt;</span><br><span class="line">	function siteTime()&#123;</span><br><span class="line">		window.setTimeout(&quot;siteTime()&quot;, 1000);</span><br><span class="line">		var seconds = 1000;</span><br><span class="line">		var minutes = seconds * 60;</span><br><span class="line">		var hours = minutes * 60;</span><br><span class="line">		var days = hours * 24;</span><br><span class="line">		var years = days * 365;</span><br><span class="line">		var today = new Date();</span><br><span class="line">		var todayYear = today.getFullYear();</span><br><span class="line">		var todayMonth = today.getMonth()+1;</span><br><span class="line">		var todayDate = today.getDate();</span><br><span class="line">		var todayHour = today.getHours();</span><br><span class="line">		var todayMinute = today.getMinutes();</span><br><span class="line">		var todaySecond = today.getSeconds();</span><br><span class="line">		/*</span><br><span class="line">		Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)</span><br><span class="line">		year - 作为date对象的年份，为4位年份值</span><br><span class="line">		month - 0-11之间的整数，做为date对象的月份</span><br><span class="line">		day - 1-31之间的整数，做为date对象的天数</span><br><span class="line">		hours - 0(午夜24点)-23之间的整数，做为date对象的小时数</span><br><span class="line">		minutes - 0-59之间的整数，做为date对象的分钟数</span><br><span class="line">		seconds - 0-59之间的整数，做为date对象的秒数</span><br><span class="line">		microseconds - 0-999之间的整数，做为date对象的毫秒数</span><br><span class="line">		*/</span><br><span class="line">		var t1 = Date.UTC(2022,02,21,13,30,00); //北京时间2018-2-13 00:00:00</span><br><span class="line">		var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);</span><br><span class="line">		var diff = t2-t1;</span><br><span class="line">		var diffYears = Math.floor(diff/years);</span><br><span class="line">		var diffDays = Math.floor((diff/days)-diffYears*365);</span><br><span class="line">		var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);</span><br><span class="line">		var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);</span><br><span class="line">		var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);</span><br><span class="line">		document.getElementById(&quot;sitetime&quot;).innerHTML=&quot; 已运行&quot;+/*diffYears+&quot; 年 &quot;+*/diffDays+&quot; 天 &quot;+diffHours+&quot; 小时 &quot;+diffMinutes+&quot; 分钟 &quot;+diffSeconds+&quot; 秒&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	siteTime();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;!--添加运行时间--&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="页脚增加网站运行时间统计next80-以上"><a class="markdownIt-Anchor" href="#页脚增加网站运行时间统计next80-以上"></a> 页脚增加网站运行时间统计(NexT8.0 以上)</h2>
<ol>
<li>
<p>找到 <code>themes/next/layout/_partials/footer.njk</code>文件</p>
</li>
<li>
<p>在末尾加入以下代码</p>
 <figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;!-- &lt;br /&gt; --&gt;</span><br><span class="line">&lt;!-- 网站运行时间的设置 --&gt;</span><br><span class="line">&lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;</span><br><span class="line">&lt;!-- &lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt; --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var now = new Date();</span><br><span class="line">function createtime() &#123;</span><br><span class="line">	var grt= new Date(&quot;02/21/2022 13:30:00&quot;);//(2022,02,21,13,30,00)</span><br><span class="line">	now.setTime(now.getTime()+250);</span><br><span class="line">	days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);</span><br><span class="line">	hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);</span><br><span class="line">	if(String(hnum).length ==1 )&#123;hnum = &quot;0&quot; + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);</span><br><span class="line">	mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = &quot;0&quot; + mnum;&#125;</span><br><span class="line">	seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);</span><br><span class="line">	snum = Math.round(seconds);</span><br><span class="line">	if(String(snum).length ==1 )&#123;snum = &quot;0&quot; + snum;&#125;</span><br><span class="line">	// var times = document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;;</span><br><span class="line">	document.getElementById(&quot;timeDate&quot;).innerHTML = &quot;本站已安全运行 &quot;+dnum+&quot; 天 &quot;+hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;;</span><br><span class="line">&#125;</span><br><span class="line">setInterval(&quot;createtime()&quot;,250);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="搜索引擎支持"><a class="markdownIt-Anchor" href="#搜索引擎支持"></a> 搜索引擎支持</h2>
<ol>
<li>
<p>各搜索引擎网站管理员中心</p>
<ul>
<li>Google：<a href="https://www.google.com/webmasters/tools">https://www.google.com/webmasters/tools</a></li>
<li>bing：<a href="https://www.bing.com/webmasters/home">https://www.bing.com/webmasters/home</a></li>
</ul>
</li>
<li>
<p>向搜索引擎提交站点</p>
<blockquote>
<p>以Google为例</p>
</blockquote>
<p>修改<code>themes/next/_config.yml</code>文件：</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Google Webmaster tools verification.</span></span><br><span class="line"><span class="comment"># See: &lt;https://www.google.com/webmasters&gt;</span></span><br><span class="line"><span class="attr">google_site_verification:</span> <span class="string">xxxxxxxxxx</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提交网站地图</p>
<blockquote>
<p>提交网站地图加快索引</p>
</blockquote>
<ol>
<li>
<p>安装插件sitemap</p>
 <figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap –save</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在<code>themes/next/_config.yml</code>中修改：</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line"><span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line"><span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line"><span class="comment">#schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line"><span class="attr">sitemap:</span> <span class="string">/sitemap.xml</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-sitemap</span></span><br><span class="line"><span class="comment">#commonweal: /404/ || fa fa-heartbeat</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>生成静态网页，上传，然后在对应搜索引擎的webmasters中添加站点地图的地址即可</p>
</li>
</ol>
</li>
<li>
<p>验证是否被检索<br />
以GitHub Pages为例，新建的GitHub Pages是没有被谷歌检索的。在谷歌搜索栏中输入如下信息进行检索：</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">site: jiahaofang.github.io</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="本地搜索功能"><a class="markdownIt-Anchor" href="#本地搜索功能"></a> 本地搜索功能</h2>
<ol>
<li>
<p>在根目录执行命令</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>配置 hexo 的<code>_config.yml</code>文件<br />
在文件末尾新增配置项</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line"> 	<span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line"> 	<span class="attr">field:</span> <span class="string">post</span></span><br><span class="line"> 	<span class="attr">format:</span> <span class="string">html</span></span><br><span class="line"> 	<span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>配置 <code>NexT</code> 主题的 <code>_config.yml</code>（根据 next 文档，应为<code>/_config.next.yml</code>）</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">	<span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Notion + Hexo + GitHub Actions + Vercel 博客解决方案</title>
    <url>//notion-hexo/</url>
    <content><![CDATA[<h1 id="博客工具"><a class="markdownIt-Anchor" href="#博客工具"></a> 博客工具</h1>
<ul>
<li>写作平台：Notion</li>
<li>博客平台：<a href="https://hexo.io/">Hexo</a></li>
<li>博客主题：<a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly@4.10.0</a></li>
<li>博客文档同步：<a href="https://github.com/LetTTGACO/elog">Elog</a></li>
<li>部署平台：Vercel</li>
<li>博客仓库：<a href="https://github.com/LetTTGACO/notion-hexo">https://github.com/LetTTGACO/notion-hexo</a></li>
</ul>
<h1 id="博客搭建指南"><a class="markdownIt-Anchor" href="#博客搭建指南"></a> 博客搭建指南</h1>
<h2 id="fork模板仓库"><a class="markdownIt-Anchor" href="#fork模板仓库"></a> Fork模板仓库</h2>
<p><a href="https://github.com/elog-x/notion-hexo/fork">点击 Fork</a> 该模板仓库到个人 Github 账号仓库下并 clone 到本地</p>
<h2 id="安装依赖"><a class="markdownIt-Anchor" href="#安装依赖"></a> 安装依赖</h2>
<p>在项目根目录下运行命令安装依赖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
<h2 id="新建-elog-本地调试文件"><a class="markdownIt-Anchor" href="#新建-elog-本地调试文件"></a> 新建 Elog 本地调试文件</h2>
<p>在项目根目录中复制<code>.elog.example.env</code>文件并改名为<code>.elog.env</code>，此文件将用于本地同步Notion 文档</p>
<h2 id="配置-notion-关键信息"><a class="markdownIt-Anchor" href="#配置-notion-关键信息"></a> 配置 Notion 关键信息</h2>
<p>按照<a href="https://elog.1874.cool/notion/gvnxobqogetukays#notion">文档提示</a>配置 Notion 并获取 <code>token</code> 和 <code>databaseId</code>，在本地<code>.elog.env</code>中写入</p>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">NOTION_TOKEN=获取的token</span><br><span class="line">NOTION_DATABASE_ID=获取的databaseId</span><br></pre></td></tr></table></figure>
<h2 id="本地调试"><a class="markdownIt-Anchor" href="#本地调试"></a> 本地调试</h2>
<p>在项目根目录运行同步命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run sync:local</span><br></pre></td></tr></table></figure>
<h2 id="启动-hexo"><a class="markdownIt-Anchor" href="#启动-hexo"></a> 启动 Hexo</h2>
<p>在项目根目录运行hexo启动命令，会自动打开本地博客</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run server</span><br></pre></td></tr></table></figure>
<h2 id="配置-hexo-博客"><a class="markdownIt-Anchor" href="#配置-hexo-博客"></a> 配置 Hexo 博客</h2>
<p>根据 <a href="https://hexo.io/">Hexo</a> 文档和 <a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a> 主题配置文档，配置你的博客直到你满意为主，你也可以换别的主题，这里不做演示</p>
<h2 id="提交代码到-github"><a class="markdownIt-Anchor" href="#提交代码到-github"></a> 提交代码到 github</h2>
<p>本地访问没问题直接提交所有文件到 Github 仓库即可</p>
<h2 id="部署到-vercel"><a class="markdownIt-Anchor" href="#部署到-vercel"></a> 部署到 Vercel</h2>
<p>注册 Vercel 账号并绑定 Github，在 Vercel 导入 该项目，Vercel 会自动识别出该 Hexo 项目，不需要改动，直接选择 Deploy 部署。部署完成会有一个 Vercel 临时域名，你也可以绑定自己的域名。</p>
<p><img src="../images/c283a83904894fe6bfaa24584cb6a86a.png" alt="Untitled.png" /></p>
<p><img src="../images/eceaaa23506d5f0d9210e8aa61d60205.png" alt="Untitled.png" /></p>
<h2 id="配置-github-actions-权限"><a class="markdownIt-Anchor" href="#配置-github-actions-权限"></a> 配置 Github Actions 权限</h2>
<p>在 Github 仓库的设置中找到 <code>Actions-General</code>，打开流水线写入权限<code>Workflow permissions</code></p>
<p><img src="../images/53b8359150ff5294ad1e88d4638940eb.png" alt="Untitled.png" /></p>
<h2 id="配置环境变量"><a class="markdownIt-Anchor" href="#配置环境变量"></a> 配置环境变量</h2>
<p>在本地运行时，用的是<code>.elog.env</code>文件中定义的 Notion 账号信息，而在 Github Actions 时，需要提前配置环境变量。</p>
<p>在 Github 仓库的设置中找到 <code>Secrets and variables</code>，新增仓库的环境变量<code>NOTION_DATABASE_ID</code>和<code>NOTION_TOKEN</code>和<code>.elog.env</code>保持一致即可</p>
<p><img src="../images/1c753720f799016f8edb30176253f472.png" alt="Untitled.png" /></p>
<h2 id="自动化部署"><a class="markdownIt-Anchor" href="#自动化部署"></a> 自动化部署</h2>
<p>当在 Notion 中改动文档后，手动/自动触发 Github Actions流水线，会重新从 Notion 增量拉取文档，自动提交代码到 Github 仓库。</p>
<p>Vercel 会实时监测仓库代码，当有新的提交时都会重新部署博客。如此就实现了自动化部署博客。</p>
<p>整个流程的关键点就在于：如何手动/自动触发 Github Actions</p>
<p>在项目.<code>github/workflows/sync.yaml</code>中已经配置了外部 API 触发 Github Actions 事件，所以只需要调用 API 触发流水线即可。</p>
<h3 id="手动触发"><a class="markdownIt-Anchor" href="#手动触发"></a> 手动触发</h3>
<p>为了方便，这里提供一个部署在 Vercel 的免费公用的<a href="https://github.com/elog-x/serverless-api"><strong>ServerlessAPI</strong></a>，只需要配置好 URL 参数并浏览器访问即可触发流水线</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">https://serverless-api-elog.vercel.app/api/github?user=xxx&amp;repo=xxx&amp;event_type=deploy&amp;token=xxx</span><br></pre></td></tr></table></figure>
<h3 id="自动触发"><a class="markdownIt-Anchor" href="#自动触发"></a> 自动触发</h3>
<p>可在 Notion 中结合 Slack 触发，<a href="https://elog.1874.cool/notion/vy55q9xwlqlsfrvk">参考教程</a>，这里就不做进一步演示了</p>
<h1 id="自定义-elog-配置"><a class="markdownIt-Anchor" href="#自定义-elog-配置"></a> 自定义 Elog 配置</h1>
<p>如果想自定义 Elog 配置，可访问 <a href="https://elog.1874.cool/">Elog 文档</a></p>
<h1 id="博客示例"><a class="markdownIt-Anchor" href="#博客示例"></a> 博客示例</h1>
<p>示例仓库：<a href="https://github.com/LetTTGACO/notion-hexo">https://github.com/LetTTGACO/notion-hexo</a></p>
<p>博客示例地址：<a href="https://notion-hexo.vercel.app/">https://notion-hexo.vercel.app</a></p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>elog</tag>
        <tag>notion</tag>
      </tags>
  </entry>
  <entry>
    <title>Notion + Hexo 博客解决方案</title>
    <url>/Notion%20+%20Hexo%20%E5%8D%9A%E5%AE%A2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="创作开发"><a class="markdownIt-Anchor" href="#创作开发"></a> 创作&amp;开发</h1>
<h2 id="notion"><a class="markdownIt-Anchor" href="#notion"></a> Notion</h2>
<ul>
<li>
<p>使用 notion 进行内容创作</p>
</li>
<li>
<p>使用 notion database 进行知识库整理</p>
<p>本文使用 hexo 平台，可参考<a href="https://1874.notion.site/867486af567f4a8897427b15ffd10b3c?v=a25aec8e27d5415e8605e43034f822bd"><strong>elog-hexo-template</strong></a> 创建数据库副本或增加必要属性到已有 Notion 数据库</p>
<p><img src="../images/e2615f760424eea3212a9e6c8e86e975.png" alt="image.png" /></p>
</li>
</ul>
<h2 id="hexo"><a class="markdownIt-Anchor" href="#hexo"></a> Hexo</h2>
<blockquote>
<p>使用 Hexo 进行博客开发</p>
</blockquote>
<ul>
<li>
<p>使用git分支保存源码</p>
<p>因Github Page要求使用master分支作为发布网站的源代码，我们只能用master分支来保存hexo生成的静态网页，对于博客源码，可以新建一个source分支来存储。在github上打开Pages对应的仓库，也就是以”<a href="http://username.github.io/">username.github.io</a>”命名的仓库，然后建立一个source分支，仓库的默认分支改为保存源码的source分支，这样通过<code>git clone</code>拉取的就是source分支代码了。</p>
</li>
<li>
<p>根据自己喜好配置 Hexo</p>
<p>这里可以自行搜索，也可以参考《Hexo 相关记录》一文</p>
</li>
<li>
<p>仓库源码大致目录结构如下</p>
  <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">.</span></span><br><span class="line"><span class="string">├──</span> <span class="string">README.md</span></span><br><span class="line"><span class="string">├──</span> <span class="string">_config.landscape.yml</span></span><br><span class="line"><span class="string">├──</span> <span class="string">_config.next.yml</span></span><br><span class="line"><span class="string">├──</span> <span class="string">_config.yml</span></span><br><span class="line"><span class="string">├──</span> <span class="string">db.json</span></span><br><span class="line"><span class="string">├──</span> <span class="string">elog.cache.json</span></span><br><span class="line"><span class="string">├──</span> <span class="string">elog.config.js</span></span><br><span class="line"><span class="string">├──</span> <span class="string">hexo.sh</span></span><br><span class="line"><span class="string">├──</span> <span class="string">node_modules</span></span><br><span class="line"><span class="string">├──</span> <span class="string">package-lock.json</span></span><br><span class="line"><span class="string">├──</span> <span class="string">package.json</span></span><br><span class="line"><span class="string">├──</span> <span class="string">public</span></span><br><span class="line"><span class="string">├──</span> <span class="string">scaffolds</span></span><br><span class="line"><span class="string">├──</span> <span class="string">source</span></span><br><span class="line"><span class="string">├──</span> <span class="string">themes</span></span><br><span class="line"><span class="string">└──</span> <span class="string">time.txt</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="cicd"><a class="markdownIt-Anchor" href="#cicd"></a> CI/CD</h1>
<blockquote>
<p>本项目持续集成的路径为：notion ⇒ slack ⇒ pipedream ⇒ elog + github action</p>
</blockquote>
<h2 id="slack"><a class="markdownIt-Anchor" href="#slack"></a> Slack</h2>
<ol>
<li>注册 <a href="%5Bhttps://slack.com/%5D(https://slack.com/)">Slack</a></li>
</ol>
<p>注册完成后创建工作区</p>
<pre><code>![image.png](../images/39b5b6f7aff90d3a40276068bc36f00e.png)
</code></pre>
<ol>
<li>
<p>创建频道（channel）</p>
<p><img src="../images/a4f3f89e1b452b4fbea77694e2b16f4a.png" alt="image.png" /></p>
</li>
<li>
<p>添加应用 Notion</p>
<p><img src="../images/6f87e4e694d8503977ee727ea0e218df.png" alt="image.png" /></p>
</li>
<li>
<p>全部创建完成后如图</p>
<p><img src="../images/8a8b173ff36627dd043c73e58ac6595b.png" alt="image.png" /></p>
</li>
</ol>
<h2 id="notion-2"><a class="markdownIt-Anchor" href="#notion-2"></a> Notion</h2>
<ol>
<li>
<p>创建 automation，设置触发器</p>
<p>在数据库页面点击闪电按钮，可以创建 <code>automation</code> ，增加触发器以及执行器</p>
<p><img src="../images/59b7ae74bc93604dd2cd965ff8239753.png" alt="image.png" /></p>
<p>根据自己喜好设置触发器，设置完成后如下</p>
<p><img src="../images/a09959b6d8f342693a06ee57658afcf6.png" alt="image.png" /></p>
</li>
</ol>
<h2 id="pipedream"><a class="markdownIt-Anchor" href="#pipedream"></a> Pipedream</h2>
<ol>
<li>
<p>注册</p>
</li>
<li>
<p>创建 Project</p>
<p><img src="../images/5802157622609c6c80ad2244909257c1.png" alt="image.png" /></p>
</li>
<li>
<p>创建 workflow</p>
<p>在 project 下创建workflow</p>
<p><img src="../images/b77409d352c2cd6111fc1210c95af271.png" alt="image.png" /></p>
</li>
<li>
<p>设置 workflow</p>
</li>
</ol>
<p>设置 workflow，触发器选择 Slack，选择<code>New Message In Channels</code> ，按照如下设置</p>
<pre><code>![image.png](../images/51ef693bc2dab2a08feb5d373debb903.png)


![image.png](../images/69e9cb0f6c83874a2091e07a199b5f5b.png)
</code></pre>
<ol>
<li>
<p>增加 Python step</p>
<p>增加一个 Python Step，代码如下所示</p>
<p><img src="../images/28846230c321742e37208feb17a242f6.png" alt="image.png" /></p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handler</span>(<span class="params">pd: <span class="string">&quot;pidedream&quot;</span></span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">        token = os.environ[<span class="string">&#x27;GITHUB_TOKEN&#x27;</span>]</span><br><span class="line">        user = <span class="string">&quot;github_username&quot;</span></span><br><span class="line">        repo = <span class="string">&quot;github_repo&quot;</span></span><br><span class="line">        event_type = <span class="string">&quot;deploy&quot;</span></span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;@elog/serverless-api&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Accept&quot;</span>: <span class="string">&#x27;*/*&#x27;</span>,</span><br><span class="line">            <span class="string">&quot;Authorization&quot;</span>: <span class="string">f&quot;token <span class="subst">&#123;token&#125;</span>&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        response = requests.post(</span><br><span class="line">            <span class="string">f&quot;https://api.github.com/repos/<span class="subst">&#123;user&#125;</span>/<span class="subst">&#123;repo&#125;</span>/dispatches&quot;</span>,</span><br><span class="line">            headers=headers,</span><br><span class="line">            data=json.dumps(&#123;<span class="string">&quot;event_type&quot;</span>: event_type&#125;)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># response.raise_for_status()</span></span><br><span class="line">        <span class="built_in">print</span>(response.text, response.json())</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: response.json() <span class="keyword">or</span> <span class="string">&#x27;Success!&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>设置完成后如图所示</p>
<p><img src="../images/e6b5dc60ca2aafd8b83df5ccfeff4a38.png" alt="image.png" /></p>
</li>
<li>
<p>配置环境变量，用于 code 中使用，在环境中通过 <code>os.environ['your_token']</code>来使用</p>
<p><img src="../images/c71d6f68e237f4b427b9e601bad2b87e.png" alt="image.png" /></p>
</li>
</ol>
<h2 id="elog-github-action"><a class="markdownIt-Anchor" href="#elog-github-action"></a> Elog + Github Action</h2>
<ol>
<li>
<p>在博客文件夹根目录配置 Elog</p>
<p>参考<a href="%5Bhttps://elog.1874.cool/notion/start%5D(https://elog.1874.cool/notion/start)">官方文档</a>进行操作，其余相关配置以官方文档为准。</p>
</li>
<li>
<p>项目添加 workflow 配置</p>
<p>在项目文件夹根目录增加 github actions 相关配置文件<code>.github/workflows/</code><strong><code>main.yaml</code></strong></p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">To</span> <span class="string">Github</span> <span class="string">Pages</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="comment"># 允许手动push触发</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">    <span class="comment"># 存放源码的分支</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">  <span class="comment"># 允许外部仓库事件触发</span></span><br><span class="line">  <span class="attr">repository_dispatch:</span></span><br><span class="line">    <span class="attr">types:</span></span><br><span class="line">  <span class="comment"># api中的event_type就是这个</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">检查分支</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@master</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">安装node环境</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@master</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&quot;16.x&quot;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">安装依赖</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          export TZ=&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line"><span class="string">          npm install --prod</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">拉取语雀/Notion的文章</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="comment"># 语雀相关环境变量</span></span><br><span class="line">          <span class="attr">YUQUE_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.YUQUE_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">YUQUE_LOGIN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.YUQUE_LOGIN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">YUQUE_REPO:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.YUQUE_REPO</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="comment"># Notion相关环境变量</span></span><br><span class="line">          <span class="attr">NOTION_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.NOTION_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">NOTION_DATABASE_ID:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.NOTION_DATABASE_ID</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="comment"># 图床相关环境变量，以腾讯云COS为例</span></span><br><span class="line">          <span class="attr">COS_SECRET_ID:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.COS_SECRET_ID</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">COS_SECRET_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.COS_SECRET_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">COS_IMAGE_BUCKET:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.COS_IMAGE_BUCKET</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">COS_IMAGE_REGION:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.COS_IMAGE_REGION</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          # 对应package.json中的script.sync</span></span><br><span class="line"><span class="string">          npm run sync</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">配置Git用户名邮箱</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          git config --global user.name &quot;xxx&quot;</span></span><br><span class="line"><span class="string">          git config --global user.email &quot;xxx@xx.com&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">提交yuque拉取的文章到GitHub仓库</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          echo `date +&quot;%Y-%m-%d %H:%M:%S&quot;` begin &gt; time.txt</span></span><br><span class="line"><span class="string">          git add .</span></span><br><span class="line"><span class="string">          git commit -m &quot;更新文档&quot; -a</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">推送文章到仓库</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">ad-m/github-push-action@master</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">github_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">生成静态文件</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          # 对应package.json中的script.build</span></span><br><span class="line"><span class="string">          npm run build</span></span><br><span class="line"><span class="string"></span>          </span><br><span class="line">      </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">部署到Github</span> <span class="string">Pages</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v4</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">	        <span class="comment"># 这里使用 github token</span></span><br><span class="line">          <span class="attr">personal_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="comment"># hexo 设置为这个路径</span></span><br><span class="line">          <span class="attr">publish_dir:</span> <span class="string">./public</span></span><br><span class="line">          <span class="attr">external_repository:</span> <span class="string">JiaHaoFang/JiaHaoFang.github.io</span></span><br><span class="line">          <span class="comment"># 存放 github page 静态文件的分支</span></span><br><span class="line">          <span class="attr">publish_branch:</span> <span class="string">master</span></span><br><span class="line">          <span class="attr">commit_message:</span> <span class="string">$&#123;&#123;</span> <span class="string">github.event.head_commit.message</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>添加环境变量</p>
<p>根据 Elog 文档获取对应的环境变量，添加到 github 仓库设置</p>
<p><img src="../images/e5c43682a02030bda9bbf86b9f2f1360.png" alt="image.png" /></p>
</li>
<li>
<p>配置Actions 执行权限</p>
<p>在仓库的 Settings-Actions-Genaral-Workflow permissions 中配置执行权限</p>
<p><img src="../images/3cbfc8ba00c1137d28e401d6f77590b6.png" alt="image.png" /></p>
</li>
<li>
<p>Github Page 设置</p>
<p>设置 Github Page 的部署分支（区分与源代码分支），这里本人使用 master 部署静态页面，使用 source 分支存放源码</p>
<p><img src="../images/c79c2a64e8754ddeef1a90f574ed7dd6.png" alt="image.png" /></p>
</li>
</ol>
<h2 id="执行效果"><a class="markdownIt-Anchor" href="#执行效果"></a> 执行效果</h2>
<ul>
<li>
<p>Slack</p>
<p><img src="../images/e3ab807c4efc51d6e852c495e0985f98.png" alt="image.png" /></p>
</li>
<li>
<p>pipedream</p>
</li>
</ul>
<p><img src="../images/9c168243848442a2eeb1bcbac9b18212.png" alt="image.png" /></p>
<ul>
<li>
<p>Github Actions</p>
<p><img src="../images/84837c7b86fe27b83755de83784d1a5d.png" alt="image.png" /></p>
<p><img src="../images/c5a6191c9835210b1a20d1b9592961f1.png" alt="image.png" /></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>elog</tag>
        <tag>notion</tag>
      </tags>
  </entry>
  <entry>
    <title>Notion-Hexo 的 Elog 配置详解</title>
    <url>//notion-notice/</url>
    <content><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>在使用 Elog 同步Notion 上的文档时，因为是将富文本向下转成 markdown，会有很多样式损失。这是由于 markdown 样式集合＜ Notion 样式集合。所以在 Notion 上书写时，得按照 markdown 支持的样式进行写作。</p>
<blockquote>
<p>可以在<a href="/notion-example/">这里</a> 看到 Notion 文档被导出为 markdown 时的样式损失程度</p>
</blockquote>
<p>如果你不能接受样式损失，可能 markdown 并不适合你，隔壁 <a href="https://github.com/tangly1024/NotionNext">NotionNext</a> 可能更适合你搭建博客。</p>
<h1 id="notion-格式注意点"><a class="markdownIt-Anchor" href="#notion-格式注意点"></a> Notion 格式注意点</h1>
<h3 id="不要使用-markdown-不支持的样式语法"><a class="markdownIt-Anchor" href="#不要使用-markdown-不支持的样式语法"></a> 不要使用 markdown 不支持的样式/语法</h3>
<p>例如字体颜色、多级折叠块、书签、数据库、嵌入等。导出为 markdown 都不能正常展示。</p>
<h3 id="适当使用-markdown-形式的超链接"><a class="markdownIt-Anchor" href="#适当使用-markdown-形式的超链接"></a> 适当使用 markdown 形式的超链接</h3>
<p>在文档中使用markdown 形式的超链接可以解决部分路由问题，例如链接Notion文档的超链接会被自动处理为非完整路径，或者手动链接到某个相对路由，可以使用以下方式解决</p>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">// 使用[]() markdown 超链接语法</span><br><span class="line">点击 [下一篇](/notion/deploy-platform) 继续配置部署平台</span><br></pre></td></tr></table></figure>
<h3 id="请勿上传视频-文件到-notion-文档"><a class="markdownIt-Anchor" href="#请勿上传视频-文件到-notion-文档"></a> 请勿上传视频、文件到 Notion 文档</h3>
<p>Elog 还暂不支持将Notion 中的视频、文件暂不支持上传到图床。如果下载到本地，短期内能访问，但因为 notion 的链接具有时效性，一般是一个小时，之后就不能查看了。</p>
<h1 id="elog-配置详解"><a class="markdownIt-Anchor" href="#elog-配置详解"></a> Elog 配置详解</h1>
<p>参考<a href="https://elog.1874.cool/">Elog 文档</a>，本博客的 Elog 的配置如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">write</span>: &#123;</span><br><span class="line">    <span class="attr">platform</span>: <span class="string">&#x27;notion&#x27;</span>,</span><br><span class="line">    <span class="attr">notion</span>: &#123;</span><br><span class="line">      <span class="attr">token</span>: process.<span class="property">env</span>.<span class="property">NOTION_TOKEN</span>,</span><br><span class="line">      <span class="attr">databaseId</span>: process.<span class="property">env</span>.<span class="property">NOTION_DATABASE_ID</span>,</span><br><span class="line">      <span class="attr">filter</span>: &#123; <span class="attr">property</span>: <span class="string">&#x27;status&#x27;</span>, <span class="attr">select</span>: &#123; <span class="attr">equals</span>: <span class="string">&#x27;已发布&#x27;</span> &#125;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">deploy</span>: &#123;</span><br><span class="line">    <span class="attr">platform</span>: <span class="string">&#x27;local&#x27;</span>,</span><br><span class="line">    <span class="attr">local</span>: &#123;</span><br><span class="line">      <span class="attr">outputDir</span>: <span class="string">&#x27;./source/_posts&#x27;</span>,</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;title&#x27;</span>,</span><br><span class="line">      <span class="attr">format</span>: <span class="string">&#x27;markdown&#x27;</span>,</span><br><span class="line">      <span class="attr">frontMatter</span>: &#123;</span><br><span class="line">        <span class="attr">enable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">include</span>: [<span class="string">&#x27;categories&#x27;</span>, <span class="string">&#x27;tags&#x27;</span>, <span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;date&#x27;</span>, <span class="string">&#x27;updated&#x27;</span>, <span class="string">&#x27;permalink&#x27;</span>, <span class="string">&#x27;cover&#x27;</span>, <span class="string">&#x27;description&#x27;</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">formatExt</span>: <span class="string">&#x27;./format-image.js&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">image</span>: &#123;</span><br><span class="line">    <span class="attr">enable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">platform</span>: <span class="string">&#x27;local&#x27;</span>,</span><br><span class="line">    <span class="attr">local</span>: &#123;</span><br><span class="line">      <span class="attr">outputDir</span>: <span class="string">&#x27;./source/images&#x27;</span>,</span><br><span class="line">      <span class="attr">prefixKey</span>: <span class="string">&#x27;/images&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="notion-配置"><a class="markdownIt-Anchor" href="#notion-配置"></a> Notion 配置</h2>
<p><img src="../images/e09e3db7b0e26c15ae5f7b720d2bf00f.png" alt="Untitled.png" /></p>
<p>根据 <a href="https://hexo.io/zh-cn/docs/front-matter">Hexo 的 FrontMatter 配置文档</a>，和 <a href="https://butterfly.js.org/posts/dc584b87/?highlight=front%20matter#Post-Front-matter">Butterfly主题的 FrontMatter 配置文档</a>，可以将需要的参数作为 notion 数据库的字段来设置。一般来说，主题的 FrontMatter 为 Hexo在一些基础字段是共用的。</p>
<ul>
<li><code>permalink</code>为文档的永久链接，例如<code>https://notion-hexo.vercel.app/notion-hexo/</code>，注意记得在结尾加上<code>/</code></li>
<li><code>categories</code>为文档的分类</li>
<li><code>tags</code> 为文档的标签</li>
<li><code>description</code>为主题配置中可选的文档描述</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">notion</span>: &#123;</span><br><span class="line">  <span class="attr">token</span>: process.<span class="property">env</span>.<span class="property">NOTION_TOKEN</span>,</span><br><span class="line">  <span class="attr">databaseId</span>: process.<span class="property">env</span>.<span class="property">NOTION_DATABASE_ID</span>,</span><br><span class="line">  <span class="attr">filter</span>: &#123; <span class="attr">property</span>: <span class="string">&#x27;status&#x27;</span>, <span class="attr">select</span>: &#123; <span class="attr">equals</span>: <span class="string">&#x27;已发布&#x27;</span> &#125;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>token</code>为 Notion Token，可从<a href="https://elog.1874.cool/notion/gvnxobqogetukays#token-1">此处</a>获取</li>
<li><code>databaseId</code>为数据库的 ID，可从<a href="https://elog.1874.cool/notion/gvnxobqogetukays#databaseid">此处</a>获取</li>
<li><code>filter</code>表示 Elog 将下载 notion 数据库属性为<code>status=已发布</code>的文档</li>
</ul>
<h2 id="本地配置"><a class="markdownIt-Anchor" href="#本地配置"></a> 本地配置</h2>
<p><img src="../images/6be21de37012453d6acaef1a2720e3ff.png" alt="Untitled.png" /></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">local</span>: &#123;</span><br><span class="line">  <span class="attr">outputDir</span>: <span class="string">&#x27;./source/_posts&#x27;</span>,</span><br><span class="line">  <span class="attr">filename</span>: <span class="string">&#x27;title&#x27;</span>,</span><br><span class="line">  <span class="attr">format</span>: <span class="string">&#x27;markdown&#x27;</span>,</span><br><span class="line">  <span class="attr">frontMatter</span>: &#123;</span><br><span class="line">    <span class="attr">enable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">include</span>: [<span class="string">&#x27;categories&#x27;</span>, <span class="string">&#x27;tags&#x27;</span>, <span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;date&#x27;</span>, <span class="string">&#x27;updated&#x27;</span>, <span class="string">&#x27;permalink&#x27;</span>, <span class="string">&#x27;cover&#x27;</span>, <span class="string">&#x27;description&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">formatExt</span>: <span class="string">&#x27;./format-image.js&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>outputDir</code>表示文档的存放位置为项目根目录下的<code>source/_posts</code>文件夹中</li>
<li><code>filename</code>表示文档将以数据库的 <code>title</code> 字段命名，也就是文档名</li>
<li><code>format</code>表示文档将以 markdown 的形式保存</li>
<li><code>frontMatter.enable</code>表示在 markdown 文档开头添加 Front Matter</li>
<li><code>frontMatter.include</code>表示只输出数组中存在的字段，数据库的其他字段忽略</li>
<li><code>formatExt=./format-image.js</code>表示将使用自定义文档插件，插件路径为项目根目录下的<code>format-image.js</code>文件</li>
</ul>
<h3 id="format-imagejs"><a class="markdownIt-Anchor" href="#format-imagejs"></a> format-image.js</h3>
<p>该文档插件的作用就是将 notion 文档最上面的<code>封面图 cover</code>，也下载到本地，并替换为本地图片链接</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; matterMarkdownAdapter &#125; = <span class="built_in">require</span>(<span class="string">&#x27;@elog/cli&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义文档插件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">DocDetail</span>&#125; doc doc的类型定义为 DocDetail</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ImageClient</span>&#125; imageClient 图床下载器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Promise&lt;DocDetail&gt;</span>&#125; 返回处理后的文档对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">format</span> = <span class="keyword">async</span> (<span class="params">doc, imageClient</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> cover = doc.<span class="property">properties</span>.<span class="property">cover</span></span><br><span class="line">  <span class="keyword">if</span> (imageClient)  &#123;</span><br><span class="line">    <span class="comment">// 只有启用图床平台image.enable=true时，imageClient才能用，否则请自行实现图片上传</span></span><br><span class="line">    <span class="keyword">const</span> url = <span class="keyword">await</span> imageClient.<span class="title function_">uploadImageFromUrl</span>(cover, doc)</span><br><span class="line">    <span class="comment">// cover链接替换为本地图片</span></span><br><span class="line">    doc.<span class="property">properties</span>.<span class="property">cover</span> = url</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将文档内容格式化为带有 Front Matter 的 markdown</span></span><br><span class="line">  doc.<span class="property">body</span> = <span class="title function_">matterMarkdownAdapter</span>(doc);</span><br><span class="line">  <span class="comment">// 返回整个文档对象</span></span><br><span class="line">  <span class="keyword">return</span> doc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 必须要暴露此方法</span></span><br><span class="line">  format,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="图床配置"><a class="markdownIt-Anchor" href="#图床配置"></a> 图床配置</h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">local</span>: &#123;</span><br><span class="line">  <span class="attr">outputDir</span>: <span class="string">&#x27;./source/images&#x27;</span>,</span><br><span class="line">  <span class="attr">prefixKey</span>: <span class="string">&#x27;/images&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>outputDir</code>表示图片的存放位置为项目根目录下的<code>source/images</code>文件夹中</li>
<li><code>prefixKey=/images</code>表示图片的统一前缀为<code>/images</code>，因为 Hexo 会将<code>source/images</code>文件夹视为<a href="https://hexo.io/zh-cn/docs/asset-folders">静态资源根目录</a>，统一将图片放在这里，并指定图片前缀，Hexo 才能找到此图片</li>
</ul>
<h2 id="更多-elog-配置详情请阅读-elog-文档"><a class="markdownIt-Anchor" href="#更多-elog-配置详情请阅读-elog-文档"></a> 更多 Elog 配置详情，请阅读 <a href="https://elog.1874.cool/">Elog 文档</a></h2>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>elog</tag>
        <tag>notion</tag>
      </tags>
  </entry>
  <entry>
    <title>Notion示例文章</title>
    <url>//notion-example/</url>
    <content><![CDATA[<h1 id="notion-markdown"><a class="markdownIt-Anchor" href="#notion-markdown"></a> Notion-Markdown</h1>
<p><a href="https://1874.notion.site/Notion-0658ee89cadf4d0e9b6adfbb1d953c70">Notion示例文章源地址</a></p>
<h2 id="行内样式"><a class="markdownIt-Anchor" href="#行内样式"></a> 行内样式</h2>
<ul>
<li><strong>加粗</strong></li>
</ul>
<p><em>斜体</em></p>
<p><u>下划线</u></p>
<p>删除线</p>
<p>行内代码 <code>const a = 123</code></p>
<p>行内公式，在Vitepress会报错，不做演示</p>
<p>红色的文字</p>
<p>蓝色的文字背景</p>
<p>绿色的块背景</p>
<h2 id="basic-block基本块"><a class="markdownIt-Anchor" href="#basic-block基本块"></a> Basic block（基本块）</h2>
<h2 id="notion示例文章的子页面"><a class="markdownIt-Anchor" href="#notion示例文章的子页面"></a> Notion示例文章的子页面</h2>
<p>Notion示例文章的子页面</p>
<table>
<thead>
<tr>
<th>表格标题</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>测试1</td>
<td>啊大大</td>
</tr>
<tr>
<td>测试2</td>
<td><code>const a = 123</code></td>
</tr>
</tbody>
</table>
<ul>
<li>无序列表</li>
</ul>
<ol>
<li>有序列表：事物按规律变化，也有一种不可避免的性质．这种性质就叫做<strong>必然性</strong>
<ol>
<li>事物的必然性，是事物本身的性质（我们反对宿命论的是其认为这一切是受神明的支配，而不是反对事物发展中存在的不可避免的性质的事实）
<ol>
<li>第三级别列表</li>
<li>第三级别列表</li>
</ol>
</li>
<li>其决定于它自己本身发展的情况和周围的条件
<ol>
<li>第三级别列表
<ol>
<li>第三级别列表</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<details>
<summary>折叠块：点击展开【一级】</summary>
<details>
<summary>点击展开【二级】</summary>
<details>
<summary>点击展开【三级】</summary>
<p>内容文本</p>
</details>
</details>
</details>
<p>123</p>
<blockquote>
<p>引用块<br />
引用换行<br />
引用换行<br />
引用 2<br />
引用 2 换行</p>
</blockquote>
<hr />
<blockquote>
<p>👏 标注文本：<strong>Elog 0.4.0-beta.7 发布了！</strong><br />
开放式跨平台博客解决方案，随意组合写作平台和部署平台</p>
<p>帮助导航👇<br />
❓ <a href="https://elog.1874.cool/notion/introduce">Elog能干什么</a><br />
🚀 <a href="https://elog.1874.cool/notion/start">快速开始</a></p>
</blockquote>
<h2 id="media媒体"><a class="markdownIt-Anchor" href="#media媒体"></a> Media（媒体）</h2>
<p><img src="../images/10a91945736a3027f2854218fa71c659.JPG" alt="cover.JPG" /></p>
<p><a href="https://elog.1874.cool">bookmark</a></p>
<p><a href="https://prod-files-secure.s3.us-west-2.amazonaws.com/809b2785-2afd-42d1-9139-e6f17eaa52c1/5999649b-7796-46a0-abd4-2e17b7b607ab/46_1677164223.mp4?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;X-Amz-Credential=ASIAZI2LB466U3JZ52J6%2F20250401%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20250401T110420Z&amp;X-Amz-Expires=3600&amp;X-Amz-Security-Token=IQoJb3JpZ2luX2VjEFMaCXVzLXdlc3QtMiJHMEUCIB7bBvi6NHXzXGG7c95gNqxq1KeUhPfTxQX40CKpWMdKAiEAg8hlxxL9nlkYfzUXA%2FHexf5neMCMBVdEKzmouCnReHcqiAQIvP%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAAGgw2Mzc0MjMxODM4MDUiDOhwbtwA5qTK9ID11CrcA0txZFijRwp6dmDvThTPhvV%2BtHX6E86JieG%2BHS9QIUqkPXN2jgcuFkYNQWTXHzwbx6YcaGSLQEvJ9YepTQ8MoCOFl9EbEmhRAh%2Feo1qapyJl5xqiPPxx4PmleFFHfVbeneCyQWbiopJRnOG48g85cUozVmK5cHrT2RS%2F89tB1Q4YydWEPHRN6Rxd7XAJTVgzR%2FTbSmYHsAHsLwTxRDLdQL2YKAQCOwllRYMg1kfvoMO8ROVHYtb8EOGf7sjiqv8288shUMmJElO0FlfoAh%2BLatLwPwjg1co9tpNvLI5Xu%2FWqsBNdKtVW9YpgbfdjNpYu%2FIIXHck8ihhV2N8zLVhcAb%2BLnSTJiSsb8HGP7MYTGAa7fp%2Fb25RApSDxkPRM4Ra8a7xrTvxqMhwv1vzHlzlWkD3pkX%2FdlmJ%2BrPI%2BHwkYbLY9LOIFlrH1eLjyFnzU35s2HUSOBWJjMlplUbLr8vrdP4Z%2BWx4CNvea%2BrYV4D1MvBEck4koKlJqftrVMgqlnhsZ7tHGBbsKKBrBTEToQiZRl3HlBuQUtGEHUxijMQWa%2Fpl6rWTmZL8LBpcXFHHu2YOnvjNB3we20%2BrNZvQ56trbSQXdVCYUjQGJ8kwSyL6fllYuP4S%2B5QrFyWY%2FpGZPMMWDr78GOqUBEr%2FR1hGf338x7l8g%2F0eCC45mgo3ZONEWYBYln6MyZ23MhMQ4oqLwFq%2BnxeMJZj9Fq100OKUij1a2P0ir7pJS1yKogwwO1i0yDeGNKSONpWDA4V%2ByaX8%2BhAWjxLbuSdVKjoQ0S1JXpFZOcsoGTHioDFdFh%2BgStXZ1W9vIbIFcuTCJmLB1lEsYt%2FfTuvp8QmdGA6idbIab4j0t4kk6eBzBzdQpQefW&amp;X-Amz-Signature=2d61c7ebe59000bb2a2d0fdf2086f900bdc6de54e72632904f006eea41df1bf6&amp;X-Amz-SignedHeaders=host&amp;x-id=GetObject">46_1677164223.mp4</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pwd=<span class="string">&#x27;123456&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;password=<span class="subst">&#123;pwd!r&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## output:</span></span><br><span class="line"><span class="comment">#password=&#x27;123456&#x27;</span></span><br></pre></td></tr></table></figure>
<p><a href="https://prod-files-secure.s3.us-west-2.amazonaws.com/809b2785-2afd-42d1-9139-e6f17eaa52c1/753c8245-2aea-45de-8a5a-509c105f6236/example.txt?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;X-Amz-Credential=ASIAZI2LB466U3JZ52J6%2F20250401%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20250401T110420Z&amp;X-Amz-Expires=3600&amp;X-Amz-Security-Token=IQoJb3JpZ2luX2VjEFMaCXVzLXdlc3QtMiJHMEUCIB7bBvi6NHXzXGG7c95gNqxq1KeUhPfTxQX40CKpWMdKAiEAg8hlxxL9nlkYfzUXA%2FHexf5neMCMBVdEKzmouCnReHcqiAQIvP%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAAGgw2Mzc0MjMxODM4MDUiDOhwbtwA5qTK9ID11CrcA0txZFijRwp6dmDvThTPhvV%2BtHX6E86JieG%2BHS9QIUqkPXN2jgcuFkYNQWTXHzwbx6YcaGSLQEvJ9YepTQ8MoCOFl9EbEmhRAh%2Feo1qapyJl5xqiPPxx4PmleFFHfVbeneCyQWbiopJRnOG48g85cUozVmK5cHrT2RS%2F89tB1Q4YydWEPHRN6Rxd7XAJTVgzR%2FTbSmYHsAHsLwTxRDLdQL2YKAQCOwllRYMg1kfvoMO8ROVHYtb8EOGf7sjiqv8288shUMmJElO0FlfoAh%2BLatLwPwjg1co9tpNvLI5Xu%2FWqsBNdKtVW9YpgbfdjNpYu%2FIIXHck8ihhV2N8zLVhcAb%2BLnSTJiSsb8HGP7MYTGAa7fp%2Fb25RApSDxkPRM4Ra8a7xrTvxqMhwv1vzHlzlWkD3pkX%2FdlmJ%2BrPI%2BHwkYbLY9LOIFlrH1eLjyFnzU35s2HUSOBWJjMlplUbLr8vrdP4Z%2BWx4CNvea%2BrYV4D1MvBEck4koKlJqftrVMgqlnhsZ7tHGBbsKKBrBTEToQiZRl3HlBuQUtGEHUxijMQWa%2Fpl6rWTmZL8LBpcXFHHu2YOnvjNB3we20%2BrNZvQ56trbSQXdVCYUjQGJ8kwSyL6fllYuP4S%2B5QrFyWY%2FpGZPMMWDr78GOqUBEr%2FR1hGf338x7l8g%2F0eCC45mgo3ZONEWYBYln6MyZ23MhMQ4oqLwFq%2BnxeMJZj9Fq100OKUij1a2P0ir7pJS1yKogwwO1i0yDeGNKSONpWDA4V%2ByaX8%2BhAWjxLbuSdVKjoQ0S1JXpFZOcsoGTHioDFdFh%2BgStXZ1W9vIbIFcuTCJmLB1lEsYt%2FfTuvp8QmdGA6idbIab4j0t4kk6eBzBzdQpQefW&amp;X-Amz-Signature=1c6349c92941cfb2be368293766e0b66c44d0bf888d6d4b980d203e9e36f74cc&amp;X-Amz-SignedHeaders=host&amp;x-id=GetObject">example.txt</a></p>
<h2 id="database数据库"><a class="markdownIt-Anchor" href="#database数据库"></a> DataBase（数据库）</h2>
<p>数据库</p>
<h2 id="ai-block"><a class="markdownIt-Anchor" href="#ai-block"></a> AI block</h2>
<p>API不支持，会报错<code>Block type ai_block is not supported via the API.</code></p>
<h2 id="advanced-block高级块"><a class="markdownIt-Anchor" href="#advanced-block高级块"></a> Advanced block（高级块）</h2>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>f</mi><mrow><mo fence="true">(</mo><msup><mrow><mo fence="true">[</mo><mfrac><mrow><mn>1</mn><mo>+</mo><mo stretchy="false">{</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">}</mo></mrow><mrow><mrow><mo fence="true">(</mo><mfrac><mi>x</mi><mi>y</mi></mfrac><mo>+</mo><mfrac><mi>y</mi><mi>x</mi></mfrac><mo fence="true">)</mo></mrow><mo stretchy="false">(</mo><mi>u</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mfrac><mo>+</mo><mi>a</mi><mo fence="true">]</mo></mrow><mrow><mn>3</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo fence="true">)</mo></mrow></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(行标)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">f\left(\left[\frac{1+\{x, y\}}{\left(\frac{x}{y}+\frac{y}{x}\right)(u+1)}+a\right]^{3 / 2}\right)\tag{行标}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.200049999999999em;vertical-align:-1.850025em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.3500249999999996em;"><span style="top:-1.9499950000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-3.1050050000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.350025em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.850025em;"><span></span></span></span></span></span></span><span class="minner"><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.11em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7475em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span><span style="top:-3.38em;"><span class="pstrut" style="height:3.15em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.827em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">{</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">}</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.69002em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">a</span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:2.3279199999999998em;"><span style="top:-4.5029200000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.3500249999999996em;"><span style="top:-1.9499950000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-3.1050050000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.350025em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.850025em;"><span></span></span></span></span></span></span></span></span><span class="tag"><span class="strut" style="height:4.200049999999999em;vertical-align:-1.850025em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">标</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>Notion示例文章的同步块</p>
<h1 id="折叠一级标题"><a class="markdownIt-Anchor" href="#折叠一级标题"></a> 折叠一级标题</h1>
<pre><code>## 折叠二级标题


    折叠内容
</code></pre>
<p>两列分栏（左）</p>
<ul>
<li>[ ] 左侧书写</li>
</ul>
<p>两列分栏（右）</p>
<ul>
<li>[ ] 右侧书写</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">Mermaid思维导图--&gt;思维导图</span><br><span class="line">Mermaid思维导图--&gt;研发</span><br></pre></td></tr></table></figure>
<p>@Anonymous</p>
<p><a href="https://www.notion.so/f478ef37c82a41f1b7a59c195b043831">Untitled</a></p>
<p>2023-04-26</p>
<p>🚀🔥🐸</p>
<h2 id="embeds嵌入"><a class="markdownIt-Anchor" href="#embeds嵌入"></a> Embeds（嵌入）</h2>
<p>嵌入网页</p>
<p><a href="https://elog.1874.cool">embed</a></p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>notion</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS代码发布为组件</title>
    <url>/iOS%E4%BB%A3%E7%A0%81%E5%8F%91%E5%B8%83%E4%B8%BA%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="1-前期准备"><a class="markdownIt-Anchor" href="#1-前期准备"></a> 1 前期准备</h2>
<h3 id="11-远程仓库"><a class="markdownIt-Anchor" href="#11-远程仓库"></a> 1.1 远程仓库</h3>
<blockquote>
<p>准备好两个远程仓库，在GitHub上创建即可；</p>
<p>权限建议为public</p>
</blockquote>
<ul>
<li>
<p>用来存放源码的仓库，该仓库用来存放自己编写的组件的源码，其应为正确的目录结构，如何模板创建下文详细说；</p>
  <figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;https://github.com/JiaHaoFang/SFAPPRealTimeLogCaughter.git&gt;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>用来存放组件的仓库，相当于xxxRepo、CocoaPods/Spec，是自己私有的组件仓库，用来存放.podspec文件；</p>
  <figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;https://github.com/JiaHaoFang/SFPodRepo.git&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>注：该仓库非必要，可以使用官方仓库，此处为了熟悉流程使用自己创建的仓库</li>
</ul>
</li>
</ul>
<h3 id="12-本地代码"><a class="markdownIt-Anchor" href="#12-本地代码"></a> 1.2 本地代码</h3>
<blockquote>
<p>由于该组件为一个完整工程作为组件发布，需要抽离</p>
</blockquote>
<ul>
<li>保证需要发布为组件的工程，其核心功能完整，去耦，能够实现核心功能的抽离</li>
<li>保证编译可通过，同时核心功能具备可移植性</li>
</ul>
<h2 id="2-本地目录创建"><a class="markdownIt-Anchor" href="#2-本地目录创建"></a> 2 本地目录创建</h2>
<h3 id="21-创建私有repo目录"><a class="markdownIt-Anchor" href="#21-创建私有repo目录"></a> 2.1 创建私有Repo目录</h3>
<ul>
<li>
<p>在～/.cocoapods/repo中能看到本地有的repo仓库，其中cocoapods为官方仓库，trunk也是官方仓库（历史遗留问题）；xxxRepo为公司私有仓库。</p>
</li>
<li>
<p>该步骤将创建私人仓库SFRepo，作用类似上文的官方仓库，后续将用来存放个人的组件。</p>
</li>
<li>
<p>或者也可以选择发布到官方仓库。</p>
</li>
<li>
<p>命令</p>
  <figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pod repo add <span class="title class_">SFPod</span> &lt;<span class="symbol">https:</span>/<span class="regexp">/github.com/</span><span class="title class_">JiaHaoFang</span>/<span class="title class_">SFPodRepo</span>.git&gt;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>创建完成之后可通过命令查看目录结构</p>
  <figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">open ~<span class="regexp">/.cocoapods/repos</span><span class="regexp">/SFPod</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="22-创建个人组件目录"><a class="markdownIt-Anchor" href="#22-创建个人组件目录"></a> 2.2 创建个人组件目录</h3>
<ul>
<li>
<p>发布的组件需要按照Cocoapod严格遵守官方给出的目录结构，官方给出了命令可以直接生成模版</p>
  <figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pod lib create <span class="title class_">SFAPPRealTimeLogCaughter</span></span><br></pre></td></tr></table></figure>
<ul>
<li>过程中终端会向我们提出一系列问题，包括开发语言是OC还是Swift，demo程序，测试框架，界面测试。我选择了包含demo程序，没有测试框架.</li>
</ul>
</li>
<li>
<p>生成模版后可以使用tree命令查看该文件夹下的目录结构</p>
</li>
</ul>
<h3 id="23-编辑模版"><a class="markdownIt-Anchor" href="#23-编辑模版"></a> 2.3 编辑模版</h3>
<blockquote>
<p>在2.2创建的公共模版就是组件的模板，我们需要将我们的代码添加进去将其作为自己的组件</p>
</blockquote>
<ul>
<li>我们需要发布的组件核心功能代码存放在/SFPod/Pod/Classes文件夹中</li>
<li>另外在Example中编写Demo测试自己的组件是否能正常工作，点击.xcworkspace可以作为一个完整工程运行</li>
<li>在写Example的时候，如果修改了Classes中文件的，需要pod install一下，将组件在自己的Demo中更新一下</li>
</ul>
<h3 id="24-编辑podspec文件"><a class="markdownIt-Anchor" href="#24-编辑podspec文件"></a> 2.4 编辑.podspec文件</h3>
<ul>
<li>自行Google</li>
</ul>
<h2 id="3-发布组件"><a class="markdownIt-Anchor" href="#3-发布组件"></a> 3 发布组件</h2>
<blockquote>
<p>如果上面的步骤完成了，恭喜，完成了一半</p>
</blockquote>
<h3 id="31-校验"><a class="markdownIt-Anchor" href="#31-校验"></a> 3.1 校验</h3>
<ul>
<li>
<p>当2中的步骤全部完成，我们可以使用下面的命令检验自己组件代码的合法性（主要是检验.podspec文件）</p>
  <figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pod lib lint</span><br><span class="line"><span class="comment"># 只从本地验证你的pod能否通过验证。</span></span><br><span class="line">pod spec lint</span><br><span class="line"><span class="comment"># 从本地和远程验证你的pod能否通过验证，建议使用这个</span></span><br><span class="line">--allow-warnings</span><br><span class="line"><span class="comment"># 如何库代码中有警告导致通不过验证。加上这个忽略警告</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="32-提交源码"><a class="markdownIt-Anchor" href="#32-提交源码"></a> 3.2 提交源码</h3>
<ul>
<li>
<p>提交源码到个人仓库</p>
  <figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">git add -a</span><br><span class="line">git commit -m &quot;xxx&quot;</span><br><span class="line">git push</span><br><span class="line">git tag 0.1.0</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="33-发布组件到个人repo"><a class="markdownIt-Anchor" href="#33-发布组件到个人repo"></a> 3.3 发布组件到个人Repo</h3>
<ul>
<li>
<p>使用命令将.podspec文件添加到~/.cocoapods/repos/SFPod中，同时也发布到远程仓库</p>
  <figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pod repo push <span class="title class_">SFPod</span> <span class="title class_">SFAPPRealTimeLogCaughter</span>.podspec</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>执行完该步骤后， ~/.cocoapods/repos/SFPod会新增对应版本的.podspec文件</p>
</li>
</ul>
<h3 id="34-查询"><a class="markdownIt-Anchor" href="#34-查询"></a> 3.4 查询</h3>
<ul>
<li>
<p>搜索组件库</p>
  <figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pod search <span class="title class_">SFAPPRealTimeLogCaughter</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>搜索到了说明安装成功</p>
</li>
</ul>
<h2 id="4-使用组件"><a class="markdownIt-Anchor" href="#4-使用组件"></a> 4 使用组件</h2>
<ul>
<li>
<p>在Podfile文件新增源</p>
  <figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">source <span class="string">&#x27;&lt;https://github.com/JiaHaoFang/SFPodRepo.git&gt;&#x27;</span></span><br><span class="line">source <span class="string">&#x27;&lt;https://github.com/CocoaPods/Specs.git&gt;&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>添加pod</p>
  <figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pod <span class="string">&#x27;SFAPPRealTimeLogCaughter&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>上面两项可以合起来写，合不起来。。。</p>
</li>
<li>
<p>执行 pod install</p>
</li>
<li>
<p>运行代码</p>
</li>
</ul>
<blockquote>
<p>参考资料：<a href="https://www.jianshu.com/p/103a6f0bf3a4">https://www.jianshu.com/p/103a6f0bf3a4</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iPad 适配二三事</title>
    <url>/iPad%20%E9%80%82%E9%85%8D%E4%BA%8C%E4%B8%89%E4%BA%8B/</url>
    <content><![CDATA[<h3 id="1-背景前言"><a class="markdownIt-Anchor" href="#1-背景前言"></a> <strong>1 背景&amp;前言</strong></h3>
<p>当谈及移动设备的应用程序开发时，iPad是一个备受关注的平台。作为一款功能强大且备受欢迎的设备，iPad是许多人日常生活中不可或缺的工具之一。对于开发者来说，确保他们的应用在iPad上的完美适配是至关重要的。</p>
<p>然而，大部分公司都会选择优先开发和推广手机端 app 的发展策略，前期不会花费过多精力在iPad 端进行适配，在 app 有了一定体量之后，用户对 iPad 端的体验提出需求之后，才会开始考虑进行 iPad 的适配。这就势必造成 iPad 的适配必须要考虑原有业务代码对适配工作造成的影响——这并不是一个简单的任务。</p>
<p>在本文中，我们将探讨一些iPad应用适配策略和最佳实践，介绍一些常见的适配问题，并提供解决方案和建议，帮助开发人员克服这些障碍。无论您是一个经验丰富的开发人员还是一个新手，我们相信这篇文章将为您提供有关在iPad上适配应用程序的经验建议和指导。</p>
<h3 id="2-技术储备"><a class="markdownIt-Anchor" href="#2-技术储备"></a> <strong>2 技术储备</strong></h3>
<h3 id="21-工程配置"><a class="markdownIt-Anchor" href="#21-工程配置"></a> <strong>2.1 工程配置</strong></h3>
<p>要让原本为 iPhone 平台开发的 app 能在 iPad 上使用，第一步就是要在 target 中添加对 iPad 平台的支持，这个配置项能让 app 在 iPad 平台运行。</p>
<p><img src="https://alidocs.dingtalk.com/core/api/resources/img/5eecdaf48460cde5250c2f5592072f73b1916d4bb99fc5c58433de2d5aa4e7b0640036fb88b8850565a117e96928706430a2b2e61e00e6494f0e630055628d18d873dd421eac6771cd5ee39a95b70c2b7216fe09f303fe3a07afbbdd4225fe9b?tmpCode=33cad466-79cd-42b3-af28-b70f8ca77a72" alt="image" /></p>
<p>经常用 iPad 的朋友们都知道，一个 app 在 iPad 端的呈现方式是十分多样化的，可以有横屏竖屏分屏浮窗等样式。在实际开发中，iPad 横竖屏的支持在 <code>iPad Orientation</code> 配置项中设置；浮窗/分屏的支持由 <code>Requires full screen</code>决定，勾选了此项之后即不支持浮窗或分屏。</p>
<p>本文主要涉及的是 iPad 横竖屏的适配，不涉及浮窗/分屏的适配。</p>
<p><img src="https://alidocs.dingtalk.com/core/api/resources/img/5eecdaf48460cde5250c2f5592072f73b1916d4bb99fc5c58433de2d5aa4e7b0640036fb88b8850565a117e9692870643e15b76dbc801406491036b8fc56f063dcff94bb73dd75d04ed3757a4994c1b34e38713706b2a07a9508fd59fedd0e8f?tmpCode=33cad466-79cd-42b3-af28-b70f8ca77a72" alt="image" /></p>
<p>到这里为止，我们的应用就可以在 iPad 上跑起来了。</p>
<h3 id="22-屏幕方向的定义"><a class="markdownIt-Anchor" href="#22-屏幕方向的定义"></a> 2.2 屏幕方向的定义</h3>
<p>对于开发者来说，app 在 iPad 上和 iPhone 上运行最大的区别就是对屏幕旋转的处理，绝大多数应用在手机上都是固定一个方向，但是在 iPad 上则需要支持多个方向的展示。另外在实际项目中，可能有一些场景，比如视频播放，需要强制应用变成横屏/竖屏，这需要我们在代码里做特殊处理。</p>
<p>要处理屏幕旋转，首先我们要知道屏幕方向是怎么定义的。在 UIKit 中， 屏幕方向一般使用<code>UIApplication.shared.statusBarOrientation</code>进行判断。它的定义如下：</p>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">public enum UIInterfaceOrientation : Int, @unchecked Sendable &#123;</span><br><span class="line">    case unknown = 0</span><br><span class="line">    case portrait = 1</span><br><span class="line">    case portraitUpsideDown = 2</span><br><span class="line">    case landscapeLeft = 4</span><br><span class="line">    case landscapeRight = 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要注意的是，有另外一个易混用的方向：<code>UIDevice.current.orientation</code>。这个变量的含义是设备的方向，为<code>UIDeviceOrientation</code>类型，包含有<code>FaceUp</code>、<code>FaceDown</code>的信息，但我们只想要屏幕的方向（横/竖），过多的类型会影响我们的判断，<strong>不推荐</strong>使用这个方式。</p>
<h3 id="23-设置屏幕方向"><a class="markdownIt-Anchor" href="#23-设置屏幕方向"></a> <strong>2.3 设置屏幕方向</strong></h3>
<p>在知道如何判断屏幕方向之后，我们就可以处理屏幕方向的旋转问题了。在开发过程中，除了 2.1 中的工程配置，常见的有两种设置方向的方式：</p>
<ol>
<li>Target - General - Deployment Info - iPad Orientation即 2.1 的工程配置，这里不再重复。</li>
<li>AppDelegate</li>
</ol>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">// 自定义属性, 用于控制全局旋转方向</span><br><span class="line">var supportOrientation: UIInterfaceOrientationMask = isPad ? .all : .portrait</span><br><span class="line"></span><br><span class="line">func application(_ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow?) -&gt; UIInterfaceOrientationMask &#123;</span><br><span class="line">    return self.supportOrientation</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 AppDelegate 中有一个方法<strong>全局</strong>可以配置 App 的展示方向，这样设置的屏幕方向优先级会高于 Target 中设置的屏幕方向。此外，这里使用一个自定义变量来存放支持的屏幕方向的原因是，我们在特定场景下可以修改<code>supportOrientation</code>的值强制更改应用的方向。</p>
<ol>
<li>UIViewController</li>
</ol>
<p>同样地，通过在 UIViewController 中设置自己的<code>supportedInterfaceOrientations</code>，可以设置某一个 VC 支持的方向：</p>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">override var shouldAutorotate: Bool &#123;</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br><span class="line">override var supportedInterfaceOrientations: UIInterfaceOrientationMask &#123;</span><br><span class="line">    return [.landscapeLeft, .landscapeRight]</span><br><span class="line">&#125;</span><br><span class="line">override var preferredInterfaceOrientationForPresentation: UIInterfaceOrientation &#123;</span><br><span class="line">    return .landscapeRight</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要特别说明的是，上面三个设置横竖屏的方式是有<strong>优先级顺序</strong>的，从上到下优先级依次提高。另外在实际开发中，对于每个根控制器 (<code>UITabBarController</code> 和 <code>UINavigationController</code>)，我们都需要设置上述第三点的三个方法</p>
<h3 id="24-监听屏幕旋转"><a class="markdownIt-Anchor" href="#24-监听屏幕旋转"></a> <strong>2.4 监听屏幕旋转</strong></h3>
<p>我们不只是希望能设置屏幕方向，我们还希望在屏幕旋转的时候我们的获取到这一事件的通知。比较常见的有几种方式获取横竖屏切换事件：</p>
<ol>
<li>在<code>UIViewController</code>中重写<code>viewWillTransition</code> 方法，系统在屏幕发生旋转的时候会调用该方法，我们在coordinator的闭包中即可处理业务。</li>
</ol>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">override func viewWillTransition(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator) &#123;</span><br><span class="line">    super.viewWillTransition(to: size, with: coordinator)</span><br><span class="line">    coordinator.animate &#123; _ in</span><br><span class="line">        // 更新UI</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>监听通知 <code>UIApplication.didChangeStatusBarOrientationNotification</code> ；在使用NotificationCenter的方式进行监听时，需要注意通知的注册和移除时机，以免造成不必要的内存泄露问题。</li>
</ol>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">func setupDeviceOrientationObserver() &#123;</span><br><span class="line">    // 开启并监听系统通知</span><br><span class="line">    UIDevice.current.beginGeneratingDeviceOrientationNotifications()</span><br><span class="line">    NotificationCenter.default.addObserver(self, selector: #selector(onDeviceOrientationChange), name: UIApplication.didChangeStatusBarOrientationNotification, object: nil)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@objc func onDeviceOrientationChange() &#123;</span><br><span class="line">    let currentDeviceOrientation = UIDevice.current.orientation</span><br><span class="line">    // 只处理竖屏或横屏的情况（可能出现unknow或屏幕朝上/朝下）</span><br><span class="line">    guard currentDeviceOrientation.isPortrait || currentDeviceOrientation.isLandscape else &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func removeDeviceOrientationObserver() &#123;</span><br><span class="line">    NotificationCenter.default.removeObserver(self, name: UIDevice.orientationDidChangeNotification, object: nil)</span><br><span class="line">    // 记得关闭使计数器-1</span><br><span class="line">    UIDevice.current.endGeneratingDeviceOrientationNotifications()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，习惯使用 Rx 的小伙伴也可以使用 RxSwift 的方式监听：</p>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">NotificationCenter.default.rx</span><br><span class="line">    .notification(UIApplication.didChangeStatusBarOrientationNotification)</span><br><span class="line">    .subscribe(onNext: &#123; [weak self] _ in</span><br><span class="line">       // 重绘 UI</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: rx.disposeBag)</span><br></pre></td></tr></table></figure>
<p>在监听设备方向的通知时，我们需要注意上文提到过的<code>UIDevice.current.orientation</code>。相对应的，<code>UIDevice.current.orientation</code>也有类似的通知方法<code>UIDevice.orientationDidChangeNotification</code>。我们使用<code>UIApplication.didChangeStatusOrientationNotification</code>通知而不是<code>UIDevice.orientationDidChangeNotification</code>通知的原因是：</p>
<ul>
<li>UIDevice 的通知会在从后台进入前台时调用三次，调用次数过多且不必要；
<ul>
<li>UIDevice 会有多个方向的通知，比如从 faceUp 转向 faceDown 时也会发出一个通知，而这个事件我们是不需要关注的</li>
</ul>
</li>
</ul>
<ol>
<li>除了上述的两种获取屏幕旋转事件的方式以外， 系统在发生屏幕旋转的行为的时候，会调用这 UIView 的<code>layoutSubviews</code> 方法和 UIViewController 的 <code>viewWillLayoutSubviews</code> 方法，我们还可以在这两个方法中进行 UI 的布局和刷新。</li>
</ol>
<h3 id="25-在旋转时刷新-ui"><a class="markdownIt-Anchor" href="#25-在旋转时刷新-ui"></a> <strong>2.5 在旋转时刷新 UI</strong></h3>
<p>在知道了如何监听屏幕旋转之后，我们接下来要做的事情就是在屏幕旋转的时候去刷新 UI。</p>
<p>在 ios 开发中，常见的页面布局方式有两种，一种是使用 <code>frame</code> 的<strong>绝对布局</strong>，一种是使用 AutoLayout 或 Masonry、SnapKit等框架的<strong>相对布局</strong>（下称<code>AutoLayout</code>）。</p>
<p>在屏幕尺寸会变化的情况下，绝对布局的方式受影响比较大，业务方需要在屏幕尺寸发生变化的时候更新这些 frame 的值。对于某些比较简单的 frame 布局的 UI，可以使用 UIView 的 <code>AutoresizingMask</code> 属性进行适配，系统会根据设置的属性对对应的 view 进行拉伸等操作。但是在实际使用中，这种方法的表现并不尽如人意，这个设置项并不能保证你的自定义视图根据你需要的方式变化。我们推荐的方案是在<code>layoutSubviews</code>方法中进行视图的 frame 的计算和赋值，这保证了代码的简洁性和 UI 的正确性。</p>
<p>而正确使用<code>AutoLayout</code>的布局方式能使页面较好地适应动态变化的屏幕尺寸，且在屏幕旋转时过渡效果流畅丝滑。 在使用自动布局的时候，我们应该摒弃手动计算尺寸的方式，譬如在处理一个横向三等分的布局的时候，我们不应该使用 “父视图宽度÷3” 的方式手动计算三个子视图的宽度，而应该在<code>AutoLayout</code> 中设置子视图的左右约束、三个子视图宽度相等，如此一来，我们就不需要再为变化的屏幕尺寸做多余的工作了。</p>
<p>根据以上原因，笔者建议在开发/适配 iPad 时应尽量使用<code>AutoLayout</code>，在遇到难以处理的 frame 布局方式时，可以考虑将其改写为<code>AutoLayout</code>。</p>
<p>此外，除了布局的原因需要刷新 UI，有些系统控件控件也需要手动刷新使其正确展示，常见的有：</p>
<ol>
<li>UICollectionView 需要调用 <code>collectionView.collectionViewLayout.invalidateLayout()</code>方法使其刷新 itemSize；</li>
<li>使用 UIScrollView 实现一些多页滑动效果的页面需要重新计算<code>contentOffset</code>使其有正确的偏移量；</li>
<li>有使用 CALayer 绘制颜色/圆角/渐变色的业务需要重新绘制 layer 使其尺寸正确。</li>
</ol>
<h3 id="3-落地方案"><a class="markdownIt-Anchor" href="#3-落地方案"></a> <strong>3 落地方案</strong></h3>
<p>本文前半段聊的都是专注于某一处业务细节如何处理屏幕旋转、尺寸变化，但实际上具体到业务落地还有很关键的一点是整体的适配方案，也就是页面的排版。</p>
<h3 id="31-常见适配方案介绍"><a class="markdownIt-Anchor" href="#31-常见适配方案介绍"></a> <strong>3.1 常见适配方案介绍</strong></h3>
<p>iPad 原生应用程序，如信息、相册、备忘录等，绝大部分采用了左右分栏的形式（如下图所示）。这种设计形式的好处在于分栏的设计能够最大化利用 iPad 的大屏，合理地利用横屏展示更多的内容。但是这种方案对原有架构的改动较大，从 UI 样式到页面交互都会发生比较大的变动，需要开发人员单独为 iPad 编写业务代码。</p>
<p>child_database</p>
<p>App Store 的设计方案采用的则是内容响应式布局，根据页面的宽度和高度按照特定的规则调整布局。这种方案灵活性更佳，用户体验好， 但是对设计人员和开发人员的要求也会更高。</p>
<p>child_database</p>
<p>最常见的适配方案就是横向拉伸页面，页面的元素按照原有的布局逻辑横向拉伸，与手机端的布局基本保持一致。这种方式既保证了页面布局的合理性，同时也不需要开发人员过多地为 iPad 单独编写代码，是一种相对折中的适配方案。</p>
<p>child_database</p>
<h3 id="32-vesync-适配方案"><a class="markdownIt-Anchor" href="#32-vesync-适配方案"></a> <strong>3.2 VeSync 适配方案</strong></h3>
<p>VeSync App 手机端用户居多，几乎所有的页面都只考虑了手机端的展示，在适配 iPad 之前，iPad 对于我们来说只是一个屏幕稍微大点的 iPhone。此外，由于 iPad 用户占比不高，公司也暂时没有在 iPad 端大力推广 VeSync App 的计划，如果要所有业务都使用 3.1 中提及的前几种方案适配，这对于我们来说成本过高。</p>
<p>由于 VeSync 是一个智能家庭类软件，大部分功能业务都与设备相关，而品类繁多的设备和功能导致业务代码体量庞大，要每个页面都完美适配 iPad 横屏/竖屏/旋转的工作量巨大。综合考虑适配成本和用户体验后，决定采用以下的适配方案：</p>
<ul>
<li>对 App 首页（即设备列表页、wellness首页、论坛、商城）这类使用频率最高的页面使用响应式布局的适配方式，最大化保证用户体验；</li>
<li>对登录页、设置页这类功能页直接横向拉伸进行适配；</li>
<li>涉及到设备业务的设备主页的业务采用<code>弹出位于屏幕中心的小窗口</code>（下称<strong>中心小窗</strong>）的适配方案。</li>
</ul>
<p>这种适配方案实际上是对 3.1 中提及的方案进行了“混搭”，再根据 VeSync 的实际情况进行调整（中心小窗）。方案综合考虑了用户体验和开发周期，在有限的开发时间内保证用户能有良好的使用体验。此外，对于开发者来说，这种方案不需要单独为 iPad 适配编写过多代码，保证了业务代码的纯净。</p>
<h3 id="33-弹出的中心小窗"><a class="markdownIt-Anchor" href="#33-弹出的中心小窗"></a> <strong>3.3 “弹出”的中心小窗</strong></h3>
<p><img src="https://alidocs.dingtalk.com/core/api/resources/img/5eecdaf48460cde5250c2f5592072f73b1916d4bb99fc5c58433de2d5aa4e7b0640036fb88b8850565a117e969287064e625f4a129c160b3978737631521d09889929b6aee2cbb183509b237bee6e05edc92b29510f5a164149565b860957ab4?tmpCode=33cad466-79cd-42b3-af28-b70f8ca77a72" alt="image" /></p>
<p>中心小窗的方案实际效果如图所示，用文字大致描述如下：</p>
<ol>
<li>涉及<strong>设备</strong>的页面都使用 Modal 的方式弹出，用一个已封装好的<code>UINavigationController</code>（下称<strong>容器</strong>）进行管理；</li>
<li>中心小窗大小根据屏幕高度计算得出，通过重写容器的<code>preferredContentSize</code>属性实现，其大小在 iPad 的横竖屏状态下均保持不变；</li>
<li>在进入中心小窗之后，后续的页面导航都在容器的导航栈里进行管理，直到这个容器被 dismiss。</li>
</ol>
<p>由于中心小窗的大小不会发生变化，大量的业务代码不需要再关心屏幕是否旋转、窗口是否发生变化，更直白地说，在中心小窗的页面的展示模式和 iPhone 基本保持一致了。这大幅减少了开发人员在这部分内容的适配工作，同时也保证了良好的用户体验。</p>
<p>在弹窗内的页面，获取容器大小的方式也要发生改变。大部分开发者会采用<code>UIScreen.main.bounds</code>的方式获取容器大小，这种方式在此方案下是有局限性的，无法获取到页面真正的大小。我们需要通过定义一个新的变量来获取当前容器的大小（W+H）。</p>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">/// 顶层控制器的宽度</span><br><span class="line">public static var adaptiveScreenW: CGFloat &#123; adaptiveScreenSize.width &#125;</span><br><span class="line">/// 顶层控制器的高度</span><br><span class="line">public static var adaptiveScreenH: CGFloat &#123; adaptiveScreenSize.height &#125;</span><br><span class="line">/// 顶层控制器的尺寸</span><br><span class="line">public static var adaptiveScreenSize: CGSize &#123;</span><br><span class="line">    guard VS.isPad, let window = UIApplication.shared.keyWindow else &#123; return screenSize &#125;</span><br><span class="line">    if let present = window.rootViewController?.presentedViewController, present.preferredContentSize != .zero &#123;</span><br><span class="line">        return present.preferredContentSize</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return window.bounds.size</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，<code>adaptiveScreenSize</code>优先获取容器的大小，否则返回屏幕大小。无论是iPhone、iPad 全屏、iPad 中心小窗，通过这种定义方式，设备方的业务代码只需要使用这一套屏幕尺寸变量即可获取正确的容器大小。</p>
<h3 id="34-中心小窗带来的变化及问题"><a class="markdownIt-Anchor" href="#34-中心小窗带来的变化及问题"></a> 3.4 中心小窗带来的变化及问题</h3>
<p>上文已经提到，中心小窗实际上是通过 present 一个封装的<code>UINavigationController</code>实现的，这样的导航管理与 iPhone 端是有区别的——从一个导航栈管理变成两个导航栈管理，这势必导致原有业务代码的导航的更新，具体需要更新的内容包括但不限于：</p>
<ol>
<li>原有的<code>popToRoot</code>事件在小窗口内会变成<code>dismiss</code>事件</li>
<li>在设备主页（此时该页面为<code>rootViewController</code>）的返回 <code>pop</code> 事件会变成<code>dismiss</code>事件，其他二级页面的返回事件保持不变</li>
<li>有些业务代码对整个栈的 <code>VC</code> 做了处理，简单地用&quot;栈内的第i个<code>VC</code>&quot;处理业务（此处的 i 指代一个代码里固定的 index 值），由于此时的导航栈结构与之前发生了变化，不能简单地用 <code>VC</code> 的 index 判断，而应该用 <code>firstIndex(of:)</code>去获取目标 VC 的下标。</li>
</ol>
<p>此外，一些作用于<code>keyWindow</code>的代码也要发生相应的变化，我们需要在获取 keyWindow 之前判断 keyWindow 是否有<code>presentedViewController</code>，如果有，我们处理的对象就应该变成<code>presentedViewController</code>。举个例子，对 keyWindow的 addSubview 操作在存在中心小窗业务的场景下应该变为：</p>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">if let presentedViewController = UIApplication.shared.keyWindow?.rootViewController?.presentedViewController &#123;</span><br><span class="line">    presentedViewController.view.addSubview(someView)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    UIApplication.shared.keyWindow?.addSubview(someView)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在中心小窗的页面还可能遇到手势冲突的问题。ios 系统原生的 Modal 支持手势下滑dismiss，如果容器内的页面有其他手势操作的业务，可能会有手势冲突的情况，常见的问题及解决方式如下：</p>
<ol>
<li>使用UISwipeGestureRecognizer造成手势冲突</li>
</ol>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">// 1. 设置手势代理</span><br><span class="line">downGes.delegate = self</span><br><span class="line">// 2. 处理冲突</span><br><span class="line">extension xxxx: UIGestureRecognizerDelegate &#123;</span><br><span class="line">    func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldBeRequiredToFailBy otherGestureRecognizer: UIGestureRecognizer) -&gt; Bool &#123;</span><br><span class="line">        return !(gestureRecognizer is UIPanGestureRecognizer)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用 UIControl 造成手势冲突</li>
</ol>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">override func gestureRecognizerShouldBegin(_ gestureRecognizer: UIGestureRecognizer) -&gt; Bool &#123;</span><br><span class="line">    return !(gestureRecognizer is UIPanGestureRecognizer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-结语"><a class="markdownIt-Anchor" href="#4-结语"></a> 4 <strong>结语</strong></h3>
<p>通过本文的介绍，我们大致了解了应用程序适配 iPad 平台的方式和技术实践。值得一提的是，在适配过程中，不断地测试和反馈是至关重要的。通过与用户进行互动和收集意见反馈，开发人员可以及时发现和解决潜在的问题，不断改进应用的性能和用户体验。</p>
<p>最后的最后，感谢您的阅读，希望本文对您在iPad应用适配方面有所启发。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>当我们在谈论DarkMode时我们在谈论什么</title>
    <url>/%E5%BD%93%E6%88%91%E4%BB%AC%E5%9C%A8%E8%B0%88%E8%AE%BADarkMode%E6%97%B6%E6%88%91%E4%BB%AC%E5%9C%A8%E8%B0%88%E8%AE%BA%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h1 id="1-前言"><a class="markdownIt-Anchor" href="#1-前言"></a> 1 前言</h1>
<p>2024年6月，Apple 在 WWDC2024 发布了iOS18。新版本的 iOS 系统中包含了一项褒贬不一的新特性：把深色模式扩展到了主屏幕的图标，这让已经融入我们生活中的深色模式功能多多少少又秀了一把存在感。</p>
<p>距离 iOS13 深色模式功能上线已经过去五年了，市面上常见的手机应用绝大部分也适配了深色模式，笔者个人更是对这一功能情有独钟，将其视为 App 中并非最重要，但不可或缺的功能之一。同时作为一个 iOS 开发者，笔者也十分清楚对于一个功能完整，已经运营了一段时间的 App 要适配这一功能需要付出怎么样的努力，这篇文章不只是对深色模式适配的介绍，也是对 VeSync App 完整适配过程的分享。</p>
<h1 id="2-原理"><a class="markdownIt-Anchor" href="#2-原理"></a> 2 原理</h1>
<p>在进行适配之前，肯定要先了解Apple 给出的相关API。本篇文章的重点其实并不是介绍这些<a href="https://developer.apple.com/documentation/uikit/appearance_customization/supporting_dark_mode_in_your_interface">官网</a>白纸黑字写清楚的东西，但是出于文章完整性的考虑，这部分内容还是必不可少的。</p>
<p>注意：下文介绍的内容均默认 App 的最低支持版本为 iOS13，省略了版本判断的相关代码。</p>
<h2 id="21-api"><a class="markdownIt-Anchor" href="#21-api"></a> 2.1 API</h2>
<ul>
<li>UIView 的 overrideUserInterfaceStyle 属性</li>
</ul>
<p>获取当前window之后，修改window的overrideUserInterfaceStyle属性，页面的颜色/图标会根据设置的模式同步更新，不需要手动操作。</p>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">guard let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene, let window = windowScene.windows.first else &#123; return &#125;</span><br><span class="line">// 设置为Light模式</span><br><span class="line">window.overrideUserInterfaceStyle = .light</span><br><span class="line"></span><br><span class="line">public enum UIUserInterfaceStyle : Int &#123;</span><br><span class="line">    // 未指明的</span><br><span class="line">    case unspecified</span><br><span class="line">    // 浅色模式</span><br><span class="line">    case light</span><br><span class="line">    // 深色模式</span><br><span class="line">    case dark</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取当前深色模式状态</li>
</ul>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">/// 在 UIView 中</span><br><span class="line">let mode = self.traitCollection.userInterfaceStyle</span><br><span class="line">/// 不在 UIView 中</span><br><span class="line">let mode = UITraitCollection.current.userInterfaceStyle</span><br></pre></td></tr></table></figure>
<ul>
<li>监听深色模式切换</li>
</ul>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) &#123;</span><br><span class="line">    if UITraitCollection.current.userInterfaceStyle == .dark &#123;</span><br><span class="line">        // Do something</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Do something else</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>某个页面单独设置不支持深色模式</li>
</ul>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">extension ViewController &#123;</span><br><span class="line">    override func viewWillAppear(_ animated: Bool) &#123;</span><br><span class="line">        super.viewWillAppear(animated)</span><br><span class="line">        self.overrideUserInterfaceStyle = .light</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="22-颜色资源支持"><a class="markdownIt-Anchor" href="#22-颜色资源支持"></a> 2.2 颜色资源支持</h2>
<p>系统提供了一种创建自定义颜色的方法</p>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">// 创建自定义颜色的方法</span><br><span class="line">public init(dynamicProvider: @escaping (UITraitCollection) -&gt; UIColor)</span><br><span class="line"></span><br><span class="line">// 通过当前traitCollection得到对应UIColor</span><br><span class="line">open func resolvedColor(with traitCollection: UITraitCollection) -&gt; UIColor</span><br></pre></td></tr></table></figure>
<p>或者在assets 中直接添加颜色资源，如下图</p>
<p><img src="../images/ebde22c5e12faedd53e48809f263135e.png" alt="image.png" /></p>
<ol>
<li>修改 Appearance 为 Any,Dark；</li>
<li>点击选中浅色/深色模式下的颜色；</li>
<li>编辑色值</li>
</ol>
<h2 id="23-图片资源支持"><a class="markdownIt-Anchor" href="#23-图片资源支持"></a> 2.3 图片资源支持</h2>
<p><img src="../images/f7d32e77d60402793b9bb235245af3f1.png" alt="image.png" /></p>
<ol>
<li>修改 Appearance 为 Any,Dark；</li>
<li>把深色模式的资源拖到对应位置；</li>
</ol>
<h2 id="24-其他需要注意的地方"><a class="markdownIt-Anchor" href="#24-其他需要注意的地方"></a> 2.4 其他需要注意的地方</h2>
<ol>
<li>CGColor 不支持动态更新颜色，原因是 CoreGraphic 是比 UIKit 更底层的库，动态更新颜色是 UIKit 支持的功能，cgColor 只会使用一开始设置的颜色色值（<code>xxx.cgColor = UIColor.systemBackground.cgColor</code>），并不会跟着系统的外观切换而动态更新色值。</li>
<li>在iOS系统切换模式之后，会调用<code>layoutSubviews</code>方法，也可以在这个方法里做UI更新</li>
<li>使用 UIGraphics 绘制的图片，可以分别绘制亮色和暗色的图片，再通过<code>UIImage.imageAsset</code>注册，让其能够自动切换外观</li>
</ol>
<h1 id="3-中场休息"><a class="markdownIt-Anchor" href="#3-中场休息"></a> 3 中场休息</h1>
<p>以上是深色模式相关的所有内容，你已经学会了，现在来试试看吧！</p>
<p><img src="../images/9041ddd09b96dc19b2e8a7d583488825.jpg" alt="%E7%BC%96%E7%A8%8B%E6%95%B0%E5%AD%A6%E4%B9%A6.jpg" /></p>
<p>开个玩笑～</p>
<p>从上面的官方接口说明中看出，深色模式的适配分为图片资源和颜色资源两个板块，如果你的 App 从一开始就使用官方的资源管理方案进行图片和颜色资源的管理，那恭喜你，你们的适配将会非常轻松，你们只需要导出图片和颜色的资源，让设计师在原有资源名字下提供深色模式的图片和颜色，比如XXX_dark，这样我们就可以通过脚本将图片和颜色资源导入资源管理库，即可完成深色模式适配的绝大部分工作。</p>
<p>实际上，理论与实践总是存在着巨大差异，接下来让我们一起看看 VeSync 在深色模式适配的实践中到底是怎么做的。</p>
<h1 id="4-图片资源处理"><a class="markdownIt-Anchor" href="#4-图片资源处理"></a> 4 图片资源处理</h1>
<p>VeSync App的图片资源，绝大多数都是使用的系统资源管理库进行管理，所以我们使用标准的处理方案进行处理即可。</p>
<h2 id="41-方案"><a class="markdownIt-Anchor" href="#41-方案"></a> 4.1 方案</h2>
<p>上文已经提过，只要在 assets 中管理的图片资源添加对应的深色模式的图片，系统就会在外观切换的时候自动切换图片的样式。按照VeSync 的图片资源命名规范，一张图片的深色样式是在原有图片名加上”_dark”或者”Dark”后缀，这取决于图片原本的命名方式是下划线还是驼峰，最终效果如：</p>
<p><img src="../images/8784a15dc04333a200710ab3c27f46d7.png" alt="image.png" /></p>
<p><img src="../images/146e5d2cbe84855cce342de2b99d021d.png" alt="image.png" /></p>
<p>但是上面只是理想情况，实际上我们还遇到了下面的问题：</p>
<ol>
<li>由于新的 UI 图片采用了统一的命名规范，导致旧版图片无法直接通过文件名匹配批量处理；</li>
<li>UI 设计师会要求在新增深色样式图片的同时，更新浅色样式的图片；</li>
<li>早期项目中相同图片被反复添加，形成了冗余资源，这些重复图片需要去重处理。</li>
</ol>
<p>以上这些问题我们都使用了脚本进行辅助处理。</p>
<h2 id="42-实施"><a class="markdownIt-Anchor" href="#42-实施"></a> 4.2 实施</h2>
<p>辅助脚本的整个流程基于图片相似度计算、脚本自动化处理与人工补充相结合。每一步的中间结果（如未匹配图片、重复图片等）都会生成 Excel 文件，以便人工确认和后续处理。</p>
<p>因为 App 的图片资源已经抽离在系统文件资源库中，对图片资源的更新不会影响到业务代码，所以这一部分工作由专人负责，负责整个 App 的所有图片的补充、替换、去重工作。工作流的大致流程图下图所示：</p>
<p>我帮您检查了全文，发现以下需要注意的地方：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A[自动匹配与配置更新] ---&gt; B[人工补充未匹配图片]</span><br><span class="line">B ---&gt; C[扫描查找重复图片]</span><br><span class="line">C ---&gt; D[删除重复图片并更新项目引用]</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>图片相似度匹配</p>
<p>使用脚本计算浅色模式图片的相似度，找到与暗色模式图片匹配的目标路径。将匹配成功的暗黑模式图片复制到目标文件夹，同时修改目标文件夹中的 Contents.json，为每张图片添加暗色模式配置。</p>
<p>这一步完成之后，大部分浅色模式图片能够匹配到对应的暗黑模式图片并完成更新。（因尺寸、色彩空间、内容轻微差异等问题）未匹配到的图片会被记录到一个 Excel 文件中，供后续人工处理。</p>
<p>注：这一步使用 OpenCV 提供的模板匹配（Template Matching）方法进行图像相似度计算以建立新旧图片之间的关系。</p>
</li>
<li>
<p>人工补充未匹配图片目标，补充第一步中未能自动匹配的图片。</p>
<p>在第一步生成的 Excel 表格人工填写未匹配图片对应的暗黑模式图片路径，将补充完成的表格作为输入，使用脚本批量将这些图片添加到目标路径，并更新 Contents.json，为所有浅色模式图片都具备对应的暗黑模式版本。</p>
</li>
<li>
<p>扫描查找重复图片，清理项目中存在的重复图片。</p>
<p>使用脚本扫描项目文件，定位所有重复的暗黑模式图片。将重复的图片记录到一个 Excel 文件中，供后续人工校对。</p>
</li>
<li>
<p>删除重复图片并更新项目中引用的图片名称。</p>
<p>人工校对第三步生成的重复图片 Excel 表格，确认需要删除的图片。此后遍历项目中所有代码源文件，查找并替换引用的旧图片路径为新图片的路径。</p>
</li>
</ol>
<h2 id="43-其他图片资源"><a class="markdownIt-Anchor" href="#43-其他图片资源"></a> 4.3 其他图片资源</h2>
<p>除了 assets 中的图片资源，我们还有两种资源：</p>
<ol>
<li>本地图片资源：一些使用不规范的图片资源没有使用 assets 管理，而是直接把资源添加到工程文件夹目录，导致了这些资源无法根据系统外观自动切换。一种处理方案是在资源使用处手动添加两个版本的图片资源使其自动切换（<code>UIImage.imageAsset</code>的方式），更优的方案是将这些资源迁移到 assets 中统一管理。</li>
<li>网络图片资源：对于 url 资源，我们无法做到动态切换。这常见于一些用户自定义的图片、头像等，也有一些配置化的资源需要存在云端，在使用的时候才会拉取下来进行展示。对于这种情况，在我们与设计团队进行沟通之后，决定对于这些资源进行统一化处理，即在深色模式和浅色模式下都用同一张图片资源，这样就免去了动态切换的麻烦。在进行统一化处理的时候，需要注意图片的背景颜色、图片透明度的问题，同时如果需要在不同外观下具有不同的背景色，则背景色应该交由 App 进行绘制，再将图片叠加其上。</li>
</ol>
<p>此外，除了单纯的图片资源，我们还有动画资源。</p>
<ol>
<li>JSON 动画资源：目前我们团队采用的动画方案是 Lottie + JSON，显而易见地，这种方案并不支持在系统层面上根据外观自动切换。我们采用的方案是手动监听系统的外观模式切换，根据系统的外观更新对应的 JSON 以达成动画的深色模式或浅色模式更新。在处理一些与当前状态相关的动画效果的时候，需要注意动画切换时的流畅性。</li>
<li>GIF 动画资源：在一些老旧的业务代码中还存留着 GIF 动画资源。与 JSON 动画类似，我们需要监听系统的外观切换，手动更新动画。</li>
</ol>
<h1 id="5-颜色资源处理"><a class="markdownIt-Anchor" href="#5-颜色资源处理"></a> 5 颜色资源处理</h1>
<p>根据官方指南，相较于以前的硬编码颜色色值的使用方式，支持深色模式的资源更适合使用语义化的名称，根据颜色的使用场景为其命名，配置好的颜色资源会自动适应当前的 App 外观。</p>
<p>在支持深色模式的场景下，颜色应该使用“颜色的场景名称”而不是“颜色的色值”。在这种定义推动下，我们“只需要”工程里用到的所有的颜色色值替换成语义化颜色名即可。</p>
<p>对于一个持续运营迭代了好几年的 App，这样子的颜色色值替换可不是简单的工作。在一个体量并不小的工程中，找出所有的颜色色值并替换会遇到下面这些问题：</p>
<ol>
<li>Swift/OC创建颜色的方法有很多种，对于这些五花八门的颜色使用方式，我们要怎么找到它们然后再一一替换成需要的资源？</li>
<li>对于海量的颜色色值，我们势必采用批量处理的方式进行替换，如果仅使用 IDE 的 Find-Replace 方式进行替换效率太低，要如何提升效率并保证准确率？</li>
<li>对于各种各样的业务及所用到的颜色色值，要怎么定义它们的一一对应关系？换句话说，原本的么处理？</li>
<li>对于 VeSync 来说，业务形态决定了某一些板块会相对独立，在开发者对某一模块并不熟悉的情况下要怎么进行这一部分的适配工作？</li>
</ol>
<p>显然，量变产生质变，要人工逐个替换已经是不可能完成的工作了，通过<code>脚本</code>进行颜色替换就是自然而然选择了。以下就介绍一下颜色处理的方案和实践流程。</p>
<h3 id="51-方案"><a class="markdownIt-Anchor" href="#51-方案"></a> 5.1 方案</h3>
<p>在脚本替换之前，我们需要先建立我们的颜色资源库。</p>
<p>根据官方指南， 我们需要一个语义化的颜色资源库。这一部分工作由设计部门完成，他们需要为 App 内所用到的所有颜色色值增加对应深色模式的颜色色值，并为其命名，形成一套完整的语义化颜色资源。</p>
<p>在拿到语义化的颜色资源后，我们要将这些颜色资源导入到工程中。由于涉及到跨部门、跨工具的合作（Zeplin/Figma、Xcode/VSCode），这一部分并没办法用脚本处理，只能人工一个个颜色搬运到工程的 .xcassets 文件中。在辛苦搬运完成后，我们就可以使用脚本读取这些资源并使用它们了。</p>
<p>至此我们有了语义化的颜色资料库，那么接下来就是识别工程中的存量的硬编码的颜色代码，并进行替换了。虽然先前的问题中提到了硬编码色值的方式多种多样，但事实上这些编码方式总是可以穷举的。既然可以穷举，那我们就可以编写脚本进行批量处理。我们采用的方式是通过遍历源文件，以正则匹配的方式获取到硬编码色值的代码段及其对应的色值。</p>
<p>当有了颜色资料库、有了工程所用到的颜色，下一步要做的事情已经显而易见了。我们对比两者，将原本的硬编码色值的相关代码替换为语义化的颜色名代码。此外，为了处理一些“边界情况”，我们需要使用 Excel 表格记录下我们的替换结果，让开发人员能够有所凭依地进行开发和检查。</p>
<p>到这里为止，我们使用脚本适配深色模式的流程就已经基本构思完成，如下流程图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A(人工导入语义化颜色资源) ---&gt; B[脚本读取.xcassets中的颜色资源]</span><br><span class="line">B -- 输出 --&gt; C1(颜色代码)</span><br><span class="line">B ---&gt; D&#123;使用色值进行比对&#125;</span><br><span class="line">D --色值不同--&gt; D1(输出 error.xml)</span><br><span class="line">E(穷举颜色编码方式) ---&gt; F[识别、解析存量的硬编码颜色]</span><br><span class="line">F ---&gt; D</span><br><span class="line">D --色值相同--&gt; G[替换硬编码颜色为语义化颜色]</span><br><span class="line">G -- 输出 --&gt; H[工程源码替换]</span><br><span class="line">G -- 输出 --&gt; H1(记录success.xml)</span><br><span class="line">H ---&gt; I(替换完成，结束)</span><br></pre></td></tr></table></figure>
<h3 id="52-实施"><a class="markdownIt-Anchor" href="#52-实施"></a> 5.2 实施</h3>
<p>接下来我们简单介绍一下具体的实践方式。</p>
<p>iOS 使用 .xcassets 的方式储存颜色资源，配置好的颜色资源如下图所示：</p>
<p><img src="../images/4f2f3449d38be5692bf965de75e11c9e.png" alt="%E9%A2%9C%E8%89%B2%E8%B5%84%E6%BA%90%E5%BA%93.png" /></p>
<p>这一个个颜色资源本质上是<code>Contents.json</code>文件：</p>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;colors&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;color&quot; : &#123;</span><br><span class="line">        &quot;color-space&quot; : &quot;srgb&quot;,</span><br><span class="line">        &quot;components&quot; : &#123;</span><br><span class="line">          &quot;alpha&quot; : &quot;1.000&quot;,</span><br><span class="line">          &quot;blue&quot; : &quot;0x89&quot;,</span><br><span class="line">          &quot;green&quot; : &quot;0x66&quot;,</span><br><span class="line">          &quot;red&quot; : &quot;0x00&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;idiom&quot; : &quot;universal&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;appearances&quot; : [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;appearance&quot; : &quot;luminosity&quot;,</span><br><span class="line">          &quot;value&quot; : &quot;dark&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;color&quot; : &#123;</span><br><span class="line">        &quot;color-space&quot; : &quot;srgb&quot;,</span><br><span class="line">        &quot;components&quot; : &#123;</span><br><span class="line">          &quot;alpha&quot; : &quot;1.000&quot;,</span><br><span class="line">          &quot;blue&quot; : &quot;0x77&quot;,</span><br><span class="line">          &quot;green&quot; : &quot;0x59&quot;,</span><br><span class="line">          &quot;red&quot; : &quot;0x02&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;idiom&quot; : &quot;universal&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;info&quot; : &#123;</span><br><span class="line">    &quot;author&quot; : &quot;xcode&quot;,</span><br><span class="line">    &quot;version&quot; : 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过解析 json 中的<code>components</code>我们可以得到颜色名和色值的对应关系。需要注意的是，<code>components</code>中的色值可能存在不同的写法，这与xcassets文件中颜色的 <code>Input Method</code>有关。</p>
<p>在读取完语义化颜色后，我们会把这些资源输出为一个单独的模块。在这一步我们使用了一些模板代码，将解析到的语义化颜色名及其色值按照 swift 规范整理成我们需要的方法及其注释，如下所示，以便在业务代码中引用。</p>
<p>这些颜色读取的脚本和模板代码应该单独抽离出来或生成一个可执行文件，为后续项目的开发新增颜色创造便利条件。</p>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">@objc public class VSColor: NSObject &#123;&#125;</span><br><span class="line">/// 语义化颜色</span><br><span class="line">public extension VSColor &#123;</span><br><span class="line">    // MARK: - Auxiliary</span><br><span class="line">    /// Light - 006689, 1.00</span><br><span class="line">    /// Dark - 025977, 1.00</span><br><span class="line">    @objc static func auxiliary_blue() -&gt; UIColor &#123;</span><br><span class="line">        return color(named: &quot;auxiliary_blue&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    /// Light - 64EDC2, 1.00</span><br><span class="line">    /// Dark - 57CBA7, 1.00</span><br><span class="line">    @objc static func auxiliary_brilliant_green() -&gt; UIColor &#123;</span><br><span class="line">        return color(named: &quot;auxiliary_brilliant_green&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似地，我们采用脚本读取工程中存量的硬编码颜色。对于各种各样的颜色编码方式，我们只能采用”比较笨”的穷举的方式，找到工程中使用的编码方式，采用字符串分割或者是正则匹配的方式提取到这一段代码块并解析色值，具体问题具体分析。这一步其实就是“玩转字符串”，相信大家一定很熟悉，笔者就不在这里献丑了。</p>
<p>事实上这一步需要处理的细节会想象中的更多，比如处理 swift、OC 的语法区别（没错，还有 OC 代码）；比如 RGBA 和 HEX 的写法需要区分和解析；比如处理浅色模式的同一个色值在深色模式下可能会有不同的色值，即同一个硬编码色值在不同的业务板块需要替换成不同的语义化颜色。</p>
<p>此外，我们除了需要记录提取到的代码块的源码、解析到的rgba值之外，还需要额外记录代码的文件位置和行数等有用信息，以便后续进行字符串替换。</p>
<p>放一个图让大家看看“穷举”到底有多少</p>
<p><img src="../images/45538b7ee06e8a22f6afe2d2902d7368.png" alt="%E9%A2%9C%E8%89%B2%E7%A9%B7%E4%B8%BE.png" /></p>
<p>接下来要做的事情就比较简单了，遍历两个数组（硬编码颜色、语义化颜色），使用他们的 rgba 值进行比对，如果硬编码颜色匹配到了对应的语义化的颜色名，则直接在源码中进行文件读写操作，替换为语义化颜色名，同时记录到 Excel 文件中。下面是这个功能的伪代码：</p>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">Read color resources into vscolor_json</span><br><span class="line">Identify and parse hardcoded colors into color_json</span><br><span class="line"></span><br><span class="line">For each sheet in color_json</span><br><span class="line">    For each line in sheet</span><br><span class="line">        If line contains &quot;red value&quot;, &quot;green value&quot;, &quot;blue value&quot;, &quot;alpha value&quot;, and &quot;result&quot; is &quot;correct&quot;</span><br><span class="line">            For each vscolor in vscolor_json</span><br><span class="line">                If line&#x27;s color values match vscolor&#x27;s color values</span><br><span class="line">                    Get file_path, line_number, old_color</span><br><span class="line">                    Determine new_color based on sheet type</span><br><span class="line">                    Print replacement information</span><br><span class="line">                    Replace color code in file</span><br><span class="line">                    Exit loop</span><br><span class="line">          Else</span><br><span class="line">              Continue to next loop</span><br></pre></td></tr></table></figure>
<p>写到这里，脚本的任务基本就完成了，这些脚本为我们提取并替换颜色，大幅度提高了工作效率，为程序员的头发作出了巨大贡献。</p>
<h3 id="53-机器队vs人工队"><a class="markdownIt-Anchor" href="#53-机器队vs人工队"></a> 5.3 机器队VS人工队</h3>
<p>VeSync App 是使用组件化的方式进行业务开发，在一个组件内的业务代码相对完整，他们的开发者对自己负责过的业务组件更加熟悉，但考虑到实际情况，这些开发者并没有很多时间投入到存量业务的深色模式适配项目中。面对这个问题，我们采用了<strong>脚本替换+人工校对+UI阶段性验收</strong>的方式进行项目开发，具体的开发流程如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    autonumber</span><br><span class="line">    participant UI as UI</span><br><span class="line">    participant Dev as App开发-负责人</span><br><span class="line">    participant Bus as App开发-业务线</span><br><span class="line"></span><br><span class="line">    UI-&gt;&gt;Dev: 按模块出设计稿</span><br><span class="line">    Note right of Dev: 开始开发流程</span><br><span class="line">    Dev-&gt;&gt;Bus: 协调模块对应开发人员</span><br><span class="line">    Bus-&gt;&gt;Dev: 业务线提前告知介入时间</span><br><span class="line">    Dev-&gt;&gt;Dev: 1. 申请Zeplin/Figma权限&lt;br&gt;2. 申请相关开发仓库分支&lt;br&gt;3. 执行颜色替换脚本&lt;br&gt;4. 大致修正颜色</span><br><span class="line">    Dev-&gt;&gt;Bus: 业务线实际介入开发</span><br><span class="line">    Note right of Bus: 业务线进行校对&amp;开发工作</span><br><span class="line">    Bus-&gt;&gt;Dev: 开发完成，返回开发负责人</span><br><span class="line">    Dev-&gt;&gt;Dev: 代码合并、打包</span><br><span class="line">    Note right of Dev: 开发完成，准备审查</span><br><span class="line">    Dev-&gt;&gt;UI: 阶段性审查</span><br><span class="line">    UI-&gt;&gt;Dev: UI问题修正</span><br><span class="line">    Note right of UI: 根据审查结果进行调整</span><br><span class="line">    Dev-&gt;&gt;UI: 最终审查</span><br><span class="line">    Note right of UI: 确认无误，流程结束</span><br></pre></td></tr></table></figure>
<p>对于上图的流程这里再做一些补充说明：</p>
<ul>
<li>App 开发-负责人：</li>
<li>申请分支：负责人会与业务线开发人员沟通，申请对应业务相关的仓库分支</li>
<li>执行脚本：在申请完分支以后，负责人会执行脚本，替换大部分颜色，保证各页面基本适配</li>
<li>大致修正颜色：对于一些特殊颜色，开发负责人会在业务线介入之前大致修正白色的使用（根据颜色的使用语境判断）</li>
<li>App 开发-业务线</li>
<li>前告知介入时间：在介入的提前两天与负责人沟通</li>
<li>实际开发：对模块的每个页面逐个核对，修正遗漏掉的颜色等错误展示效果</li>
</ul>
<p>按照上面的流程，深色模式的适配对于业务线的开发者来说，只需要如常执行他们的业务流程，指出并修复个别错误展示效果（颜色或图片），而工作量最大的颜色替换部分则由项目负责人使用脚本进行处理。在一个板块的适配完成后，会打包交付 UI、产品阶段性验收，验收完成后，开发再针对提出的 UI 问题进行修改。这样一来，我们就同时保证了开发的效率和准确率。</p>
<h1 id="6-尾声"><a class="markdownIt-Anchor" href="#6-尾声"></a> 6 尾声</h1>
<p>在探讨了深色模式的技术细节之后，我们不难发现，尽管其核心概念和实现方法在技术层面上并不复杂，但真正要将深色模式完美融入我们的应用中，却远非易事。对于已经上线并拥有一定用户基础的应用来说，如何在不破坏现有功能和用户体验的前提下，平滑过渡到深色模式，是一个需要精心策划和逐步实施的过程。虽然技术实现本身并不复杂，但要真正做到完美适配，却需要我们投入更多的精力和智慧。在未来，随着用户对个性化和舒适度要求的不断提高，深色模式无疑将成为应用中不可或缺的一部分。我们期待，通过不断的探索和实践，能够为用户带来更加丰富和舒适的使用体验。</p>
<p>感谢您的阅读，希望本文能够为您提供一些关于深色模式适配的有益见解和启发。如果您有任何疑问或建议，欢迎留言交流。</p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
</search>
