{"meta":{"title":"阿告今天学习了吗","subtitle":"","description":"","author":"阿告2426","url":"https://jiahaofang.github.io","root":"/"},"pages":[{"title":"","date":"2025-04-01T12:25:20.821Z","updated":"2025-04-01T12:25:20.821Z","comments":true,"path":"404.html","permalink":"https://jiahaofang.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2025-04-01T12:25:20.821Z","updated":"2025-04-01T12:25:20.821Z","comments":true,"path":"about/index.html","permalink":"https://jiahaofang.github.io/about/index.html","excerpt":"","text":"About me"},{"title":"categories","date":"2022-02-22T11:29:09.000Z","updated":"2025-04-01T12:25:20.822Z","comments":true,"path":"categories/index.html","permalink":"https://jiahaofang.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2014-12-22T12:39:04.000Z","updated":"2025-04-01T12:25:20.822Z","comments":true,"path":"tags/index.html","permalink":"https://jiahaofang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"iPad 适配二三事","slug":"iPad 适配二三事","date":"2025-04-01T19:23:00.000Z","updated":"2025-04-01T19:29:00.000Z","comments":true,"path":"iPad 适配二三事/","link":"","permalink":"https://jiahaofang.github.io/iPad%20%E9%80%82%E9%85%8D%E4%BA%8C%E4%B8%89%E4%BA%8B/","excerpt":"1 背景&amp;前言","text":"1 背景&amp;前言 当谈及移动设备的应用程序开发时，iPad是一个备受关注的平台。作为一款功能强大且备受欢迎的设备，iPad是许多人日常生活中不可或缺的工具之一。对于开发者来说，确保他们的应用在iPad上的完美适配是至关重要的。 然而，大部分公司都会选择优先开发和推广手机端 app 的发展策略，前期不会花费过多精力在iPad 端进行适配，在 app 有了一定体量之后，用户对 iPad 端的体验提出需求之后，才会开始考虑进行 iPad 的适配。这就势必造成 iPad 的适配必须要考虑原有业务代码对适配工作造成的影响——这并不是一个简单的任务。 在本文中，我们将探讨一些iPad应用适配策略和最佳实践，介绍一些常见的适配问题，并提供解决方案和建议，帮助开发人员克服这些障碍。无论您是一个经验丰富的开发人员还是一个新手，我们相信这篇文章将为您提供有关在iPad上适配应用程序的经验建议和指导。 2 技术储备 2.1 工程配置 要让原本为 iPhone 平台开发的 app 能在 iPad 上使用，第一步就是要在 target 中添加对 iPad 平台的支持，这个配置项能让 app 在 iPad 平台运行。 经常用 iPad 的朋友们都知道，一个 app 在 iPad 端的呈现方式是十分多样化的，可以有横屏竖屏分屏浮窗等样式。在实际开发中，iPad 横竖屏的支持在 iPad Orientation 配置项中设置；浮窗/分屏的支持由 Requires full screen决定，勾选了此项之后即不支持浮窗或分屏。 本文主要涉及的是 iPad 横竖屏的适配，不涉及浮窗/分屏的适配。 到这里为止，我们的应用就可以在 iPad 上跑起来了。 2.2 屏幕方向的定义 对于开发者来说，app 在 iPad 上和 iPhone 上运行最大的区别就是对屏幕旋转的处理，绝大多数应用在手机上都是固定一个方向，但是在 iPad 上则需要支持多个方向的展示。另外在实际项目中，可能有一些场景，比如视频播放，需要强制应用变成横屏/竖屏，这需要我们在代码里做特殊处理。 要处理屏幕旋转，首先我们要知道屏幕方向是怎么定义的。在 UIKit 中， 屏幕方向一般使用UIApplication.shared.statusBarOrientation进行判断。它的定义如下： text1234567public enum UIInterfaceOrientation : Int, @unchecked Sendable &#123; case unknown = 0 case portrait = 1 case portraitUpsideDown = 2 case landscapeLeft = 4 case landscapeRight = 3&#125; 要注意的是，有另外一个易混用的方向：UIDevice.current.orientation。这个变量的含义是设备的方向，为UIDeviceOrientation类型，包含有FaceUp、FaceDown的信息，但我们只想要屏幕的方向（横/竖），过多的类型会影响我们的判断，不推荐使用这个方式。 2.3 设置屏幕方向 在知道如何判断屏幕方向之后，我们就可以处理屏幕方向的旋转问题了。在开发过程中，除了 2.1 中的工程配置，常见的有两种设置方向的方式： Target - General - Deployment Info - iPad Orientation即 2.1 的工程配置，这里不再重复。 AppDelegate text123456// 自定义属性, 用于控制全局旋转方向var supportOrientation: UIInterfaceOrientationMask = isPad ? .all : .portraitfunc application(_ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow?) -&gt; UIInterfaceOrientationMask &#123; return self.supportOrientation&#125; 在 AppDelegate 中有一个方法全局可以配置 App 的展示方向，这样设置的屏幕方向优先级会高于 Target 中设置的屏幕方向。此外，这里使用一个自定义变量来存放支持的屏幕方向的原因是，我们在特定场景下可以修改supportOrientation的值强制更改应用的方向。 UIViewController 同样地，通过在 UIViewController 中设置自己的supportedInterfaceOrientations，可以设置某一个 VC 支持的方向： text123456789override var shouldAutorotate: Bool &#123; return true&#125;override var supportedInterfaceOrientations: UIInterfaceOrientationMask &#123; return [.landscapeLeft, .landscapeRight]&#125;override var preferredInterfaceOrientationForPresentation: UIInterfaceOrientation &#123; return .landscapeRight&#125; 这里需要特别说明的是，上面三个设置横竖屏的方式是有优先级顺序的，从上到下优先级依次提高。另外在实际开发中，对于每个根控制器 (UITabBarController 和 UINavigationController)，我们都需要设置上述第三点的三个方法 2.4 监听屏幕旋转 我们不只是希望能设置屏幕方向，我们还希望在屏幕旋转的时候我们的获取到这一事件的通知。比较常见的有几种方式获取横竖屏切换事件： 在UIViewController中重写viewWillTransition 方法，系统在屏幕发生旋转的时候会调用该方法，我们在coordinator的闭包中即可处理业务。 text123456override func viewWillTransition(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator) &#123; super.viewWillTransition(to: size, with: coordinator) coordinator.animate &#123; _ in // 更新UI &#125;&#125; 监听通知 UIApplication.didChangeStatusBarOrientationNotification ；在使用NotificationCenter的方式进行监听时，需要注意通知的注册和移除时机，以免造成不必要的内存泄露问题。 text12345678910111213141516171819func setupDeviceOrientationObserver() &#123; // 开启并监听系统通知 UIDevice.current.beginGeneratingDeviceOrientationNotifications() NotificationCenter.default.addObserver(self, selector: #selector(onDeviceOrientationChange), name: UIApplication.didChangeStatusBarOrientationNotification, object: nil)&#125;@objc func onDeviceOrientationChange() &#123; let currentDeviceOrientation = UIDevice.current.orientation // 只处理竖屏或横屏的情况（可能出现unknow或屏幕朝上/朝下） guard currentDeviceOrientation.isPortrait || currentDeviceOrientation.isLandscape else &#123; return &#125;&#125;func removeDeviceOrientationObserver() &#123; NotificationCenter.default.removeObserver(self, name: UIDevice.orientationDidChangeNotification, object: nil) // 记得关闭使计数器-1 UIDevice.current.endGeneratingDeviceOrientationNotifications()&#125; 另外，习惯使用 Rx 的小伙伴也可以使用 RxSwift 的方式监听： text123456NotificationCenter.default.rx .notification(UIApplication.didChangeStatusBarOrientationNotification) .subscribe(onNext: &#123; [weak self] _ in // 重绘 UI &#125;) .disposed(by: rx.disposeBag) 在监听设备方向的通知时，我们需要注意上文提到过的UIDevice.current.orientation。相对应的，UIDevice.current.orientation也有类似的通知方法UIDevice.orientationDidChangeNotification。我们使用UIApplication.didChangeStatusOrientationNotification通知而不是UIDevice.orientationDidChangeNotification通知的原因是： UIDevice 的通知会在从后台进入前台时调用三次，调用次数过多且不必要； UIDevice 会有多个方向的通知，比如从 faceUp 转向 faceDown 时也会发出一个通知，而这个事件我们是不需要关注的 除了上述的两种获取屏幕旋转事件的方式以外， 系统在发生屏幕旋转的行为的时候，会调用这 UIView 的layoutSubviews 方法和 UIViewController 的 viewWillLayoutSubviews 方法，我们还可以在这两个方法中进行 UI 的布局和刷新。 2.5 在旋转时刷新 UI 在知道了如何监听屏幕旋转之后，我们接下来要做的事情就是在屏幕旋转的时候去刷新 UI。 在 ios 开发中，常见的页面布局方式有两种，一种是使用 frame 的绝对布局，一种是使用 AutoLayout 或 Masonry、SnapKit等框架的相对布局（下称AutoLayout）。 在屏幕尺寸会变化的情况下，绝对布局的方式受影响比较大，业务方需要在屏幕尺寸发生变化的时候更新这些 frame 的值。对于某些比较简单的 frame 布局的 UI，可以使用 UIView 的 AutoresizingMask 属性进行适配，系统会根据设置的属性对对应的 view 进行拉伸等操作。但是在实际使用中，这种方法的表现并不尽如人意，这个设置项并不能保证你的自定义视图根据你需要的方式变化。我们推荐的方案是在layoutSubviews方法中进行视图的 frame 的计算和赋值，这保证了代码的简洁性和 UI 的正确性。 而正确使用AutoLayout的布局方式能使页面较好地适应动态变化的屏幕尺寸，且在屏幕旋转时过渡效果流畅丝滑。 在使用自动布局的时候，我们应该摒弃手动计算尺寸的方式，譬如在处理一个横向三等分的布局的时候，我们不应该使用 “父视图宽度÷3” 的方式手动计算三个子视图的宽度，而应该在AutoLayout 中设置子视图的左右约束、三个子视图宽度相等，如此一来，我们就不需要再为变化的屏幕尺寸做多余的工作了。 根据以上原因，笔者建议在开发/适配 iPad 时应尽量使用AutoLayout，在遇到难以处理的 frame 布局方式时，可以考虑将其改写为AutoLayout。 此外，除了布局的原因需要刷新 UI，有些系统控件控件也需要手动刷新使其正确展示，常见的有： UICollectionView 需要调用 collectionView.collectionViewLayout.invalidateLayout()方法使其刷新 itemSize； 使用 UIScrollView 实现一些多页滑动效果的页面需要重新计算contentOffset使其有正确的偏移量； 有使用 CALayer 绘制颜色/圆角/渐变色的业务需要重新绘制 layer 使其尺寸正确。 3 落地方案 本文前半段聊的都是专注于某一处业务细节如何处理屏幕旋转、尺寸变化，但实际上具体到业务落地还有很关键的一点是整体的适配方案，也就是页面的排版。 3.1 常见适配方案介绍 iPad 原生应用程序，如信息、相册、备忘录等，绝大部分采用了左右分栏的形式（如下图所示）。这种设计形式的好处在于分栏的设计能够最大化利用 iPad 的大屏，合理地利用横屏展示更多的内容。但是这种方案对原有架构的改动较大，从 UI 样式到页面交互都会发生比较大的变动，需要开发人员单独为 iPad 编写业务代码。 child_database App Store 的设计方案采用的则是内容响应式布局，根据页面的宽度和高度按照特定的规则调整布局。这种方案灵活性更佳，用户体验好， 但是对设计人员和开发人员的要求也会更高。 child_database 最常见的适配方案就是横向拉伸页面，页面的元素按照原有的布局逻辑横向拉伸，与手机端的布局基本保持一致。这种方式既保证了页面布局的合理性，同时也不需要开发人员过多地为 iPad 单独编写代码，是一种相对折中的适配方案。 child_database 3.2 VeSync 适配方案 VeSync App 手机端用户居多，几乎所有的页面都只考虑了手机端的展示，在适配 iPad 之前，iPad 对于我们来说只是一个屏幕稍微大点的 iPhone。此外，由于 iPad 用户占比不高，公司也暂时没有在 iPad 端大力推广 VeSync App 的计划，如果要所有业务都使用 3.1 中提及的前几种方案适配，这对于我们来说成本过高。 由于 VeSync 是一个智能家庭类软件，大部分功能业务都与设备相关，而品类繁多的设备和功能导致业务代码体量庞大，要每个页面都完美适配 iPad 横屏/竖屏/旋转的工作量巨大。综合考虑适配成本和用户体验后，决定采用以下的适配方案： 对 App 首页（即设备列表页、wellness首页、论坛、商城）这类使用频率最高的页面使用响应式布局的适配方式，最大化保证用户体验； 对登录页、设置页这类功能页直接横向拉伸进行适配； 涉及到设备业务的设备主页的业务采用弹出位于屏幕中心的小窗口（下称中心小窗）的适配方案。 这种适配方案实际上是对 3.1 中提及的方案进行了“混搭”，再根据 VeSync 的实际情况进行调整（中心小窗）。方案综合考虑了用户体验和开发周期，在有限的开发时间内保证用户能有良好的使用体验。此外，对于开发者来说，这种方案不需要单独为 iPad 适配编写过多代码，保证了业务代码的纯净。 3.3 “弹出”的中心小窗 中心小窗的方案实际效果如图所示，用文字大致描述如下： 涉及设备的页面都使用 Modal 的方式弹出，用一个已封装好的UINavigationController（下称容器）进行管理； 中心小窗大小根据屏幕高度计算得出，通过重写容器的preferredContentSize属性实现，其大小在 iPad 的横竖屏状态下均保持不变； 在进入中心小窗之后，后续的页面导航都在容器的导航栈里进行管理，直到这个容器被 dismiss。 由于中心小窗的大小不会发生变化，大量的业务代码不需要再关心屏幕是否旋转、窗口是否发生变化，更直白地说，在中心小窗的页面的展示模式和 iPhone 基本保持一致了。这大幅减少了开发人员在这部分内容的适配工作，同时也保证了良好的用户体验。 在弹窗内的页面，获取容器大小的方式也要发生改变。大部分开发者会采用UIScreen.main.bounds的方式获取容器大小，这种方式在此方案下是有局限性的，无法获取到页面真正的大小。我们需要通过定义一个新的变量来获取当前容器的大小（W+H）。 text12345678910111213/// 顶层控制器的宽度public static var adaptiveScreenW: CGFloat &#123; adaptiveScreenSize.width &#125;/// 顶层控制器的高度public static var adaptiveScreenH: CGFloat &#123; adaptiveScreenSize.height &#125;/// 顶层控制器的尺寸public static var adaptiveScreenSize: CGSize &#123; guard VS.isPad, let window = UIApplication.shared.keyWindow else &#123; return screenSize &#125; if let present = window.rootViewController?.presentedViewController, present.preferredContentSize != .zero &#123; return present.preferredContentSize &#125; else &#123; return window.bounds.size &#125;&#125; 可以看出，adaptiveScreenSize优先获取容器的大小，否则返回屏幕大小。无论是iPhone、iPad 全屏、iPad 中心小窗，通过这种定义方式，设备方的业务代码只需要使用这一套屏幕尺寸变量即可获取正确的容器大小。 3.4 中心小窗带来的变化及问题 上文已经提到，中心小窗实际上是通过 present 一个封装的UINavigationController实现的，这样的导航管理与 iPhone 端是有区别的——从一个导航栈管理变成两个导航栈管理，这势必导致原有业务代码的导航的更新，具体需要更新的内容包括但不限于： 原有的popToRoot事件在小窗口内会变成dismiss事件 在设备主页（此时该页面为rootViewController）的返回 pop 事件会变成dismiss事件，其他二级页面的返回事件保持不变 有些业务代码对整个栈的 VC 做了处理，简单地用&quot;栈内的第i个VC&quot;处理业务（此处的 i 指代一个代码里固定的 index 值），由于此时的导航栈结构与之前发生了变化，不能简单地用 VC 的 index 判断，而应该用 firstIndex(of:)去获取目标 VC 的下标。 此外，一些作用于keyWindow的代码也要发生相应的变化，我们需要在获取 keyWindow 之前判断 keyWindow 是否有presentedViewController，如果有，我们处理的对象就应该变成presentedViewController。举个例子，对 keyWindow的 addSubview 操作在存在中心小窗业务的场景下应该变为： text12345if let presentedViewController = UIApplication.shared.keyWindow?.rootViewController?.presentedViewController &#123; presentedViewController.view.addSubview(someView)&#125; else &#123; UIApplication.shared.keyWindow?.addSubview(someView)&#125; 在中心小窗的页面还可能遇到手势冲突的问题。ios 系统原生的 Modal 支持手势下滑dismiss，如果容器内的页面有其他手势操作的业务，可能会有手势冲突的情况，常见的问题及解决方式如下： 使用UISwipeGestureRecognizer造成手势冲突 text12345678// 1. 设置手势代理downGes.delegate = self// 2. 处理冲突extension xxxx: UIGestureRecognizerDelegate &#123; func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldBeRequiredToFailBy otherGestureRecognizer: UIGestureRecognizer) -&gt; Bool &#123; return !(gestureRecognizer is UIPanGestureRecognizer) &#125;&#125; 使用 UIControl 造成手势冲突 text123override func gestureRecognizerShouldBegin(_ gestureRecognizer: UIGestureRecognizer) -&gt; Bool &#123; return !(gestureRecognizer is UIPanGestureRecognizer)&#125; 4 结语 通过本文的介绍，我们大致了解了应用程序适配 iPad 平台的方式和技术实践。值得一提的是，在适配过程中，不断地测试和反馈是至关重要的。通过与用户进行互动和收集意见反馈，开发人员可以及时发现和解决潜在的问题，不断改进应用的性能和用户体验。 最后的最后，感谢您的阅读，希望本文对您在iPad应用适配方面有所启发。","categories":[{"name":"Coding","slug":"Coding","permalink":"https://jiahaofang.github.io/categories/Coding/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://jiahaofang.github.io/tags/iOS/"}]},{"title":"当我们在谈论DarkMode时我们在谈论什么","slug":"当我们在谈论DarkMode时我们在谈论什么","date":"2025-04-01T19:22:00.000Z","updated":"2025-04-01T20:14:00.000Z","comments":true,"path":"当我们在谈论DarkMode时我们在谈论什么/","link":"","permalink":"https://jiahaofang.github.io/%E5%BD%93%E6%88%91%E4%BB%AC%E5%9C%A8%E8%B0%88%E8%AE%BADarkMode%E6%97%B6%E6%88%91%E4%BB%AC%E5%9C%A8%E8%B0%88%E8%AE%BA%E4%BB%80%E4%B9%88/","excerpt":"1 前言","text":"1 前言 2024年6月，Apple 在 WWDC2024 发布了iOS18。新版本的 iOS 系统中包含了一项褒贬不一的新特性：把深色模式扩展到了主屏幕的图标，这让已经融入我们生活中的深色模式功能多多少少又秀了一把存在感。 距离 iOS13 深色模式功能上线已经过去五年了，市面上常见的手机应用绝大部分也适配了深色模式，笔者个人更是对这一功能情有独钟，将其视为 App 中并非最重要，但不可或缺的功能之一。同时作为一个 iOS 开发者，笔者也十分清楚对于一个功能完整，已经运营了一段时间的 App 要适配这一功能需要付出怎么样的努力，这篇文章不只是对深色模式适配的介绍，也是对 VeSync App 完整适配过程的分享。 2 原理 在进行适配之前，肯定要先了解Apple 给出的相关API。本篇文章的重点其实并不是介绍这些官网白纸黑字写清楚的东西，但是出于文章完整性的考虑，这部分内容还是必不可少的。 注意：下文介绍的内容均默认 App 的最低支持版本为 iOS13，省略了版本判断的相关代码。 2.1 API UIView 的 overrideUserInterfaceStyle 属性 获取当前window之后，修改window的overrideUserInterfaceStyle属性，页面的颜色/图标会根据设置的模式同步更新，不需要手动操作。 text123456789101112guard let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene, let window = windowScene.windows.first else &#123; return &#125;// 设置为Light模式window.overrideUserInterfaceStyle = .lightpublic enum UIUserInterfaceStyle : Int &#123; // 未指明的 case unspecified // 浅色模式 case light // 深色模式 case dark&#125; 获取当前深色模式状态 text1234/// 在 UIView 中let mode = self.traitCollection.userInterfaceStyle/// 不在 UIView 中let mode = UITraitCollection.current.userInterfaceStyle 监听深色模式切换 text1234567override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) &#123; if UITraitCollection.current.userInterfaceStyle == .dark &#123; // Do something &#125; else &#123; // Do something else &#125;&#125; 某个页面单独设置不支持深色模式 text123456extension ViewController &#123; override func viewWillAppear(_ animated: Bool) &#123; super.viewWillAppear(animated) self.overrideUserInterfaceStyle = .light &#125;&#125; 2.2 颜色资源支持 系统提供了一种创建自定义颜色的方法 text12345// 创建自定义颜色的方法public init(dynamicProvider: @escaping (UITraitCollection) -&gt; UIColor)// 通过当前traitCollection得到对应UIColoropen func resolvedColor(with traitCollection: UITraitCollection) -&gt; UIColor 或者在assets 中直接添加颜色资源，如下图 修改 Appearance 为 Any,Dark； 点击选中浅色/深色模式下的颜色； 编辑色值 2.3 图片资源支持 修改 Appearance 为 Any,Dark； 把深色模式的资源拖到对应位置； 2.4 其他需要注意的地方 CGColor 不支持动态更新颜色，原因是 CoreGraphic 是比 UIKit 更底层的库，动态更新颜色是 UIKit 支持的功能，cgColor 只会使用一开始设置的颜色色值（xxx.cgColor = UIColor.systemBackground.cgColor），并不会跟着系统的外观切换而动态更新色值。 在iOS系统切换模式之后，会调用layoutSubviews方法，也可以在这个方法里做UI更新 使用 UIGraphics 绘制的图片，可以分别绘制亮色和暗色的图片，再通过UIImage.imageAsset注册，让其能够自动切换外观 3 中场休息 以上是深色模式相关的所有内容，你已经学会了，现在来试试看吧！ 开个玩笑～ 从上面的官方接口说明中看出，深色模式的适配分为图片资源和颜色资源两个板块，如果你的 App 从一开始就使用官方的资源管理方案进行图片和颜色资源的管理，那恭喜你，你们的适配将会非常轻松，你们只需要导出图片和颜色的资源，让设计师在原有资源名字下提供深色模式的图片和颜色，比如XXX_dark，这样我们就可以通过脚本将图片和颜色资源导入资源管理库，即可完成深色模式适配的绝大部分工作。 实际上，理论与实践总是存在着巨大差异，接下来让我们一起看看 VeSync 在深色模式适配的实践中到底是怎么做的。 4 图片资源处理 VeSync App的图片资源，绝大多数都是使用的系统资源管理库进行管理，所以我们使用标准的处理方案进行处理即可。 4.1 方案 上文已经提过，只要在 assets 中管理的图片资源添加对应的深色模式的图片，系统就会在外观切换的时候自动切换图片的样式。按照VeSync 的图片资源命名规范，一张图片的深色样式是在原有图片名加上”_dark”或者”Dark”后缀，这取决于图片原本的命名方式是下划线还是驼峰，最终效果如： 但是上面只是理想情况，实际上我们还遇到了下面的问题： 由于新的 UI 图片采用了统一的命名规范，导致旧版图片无法直接通过文件名匹配批量处理； UI 设计师会要求在新增深色样式图片的同时，更新浅色样式的图片； 早期项目中相同图片被反复添加，形成了冗余资源，这些重复图片需要去重处理。 以上这些问题我们都使用了脚本进行辅助处理。 4.2 实施 辅助脚本的整个流程基于图片相似度计算、脚本自动化处理与人工补充相结合。每一步的中间结果（如未匹配图片、重复图片等）都会生成 Excel 文件，以便人工确认和后续处理。 因为 App 的图片资源已经抽离在系统文件资源库中，对图片资源的更新不会影响到业务代码，所以这一部分工作由专人负责，负责整个 App 的所有图片的补充、替换、去重工作。工作流的大致流程图下图所示： 我帮您检查了全文，发现以下需要注意的地方： 1234graph TBA[自动匹配与配置更新] ---&gt; B[人工补充未匹配图片]B ---&gt; C[扫描查找重复图片]C ---&gt; D[删除重复图片并更新项目引用] 图片相似度匹配 使用脚本计算浅色模式图片的相似度，找到与暗色模式图片匹配的目标路径。将匹配成功的暗黑模式图片复制到目标文件夹，同时修改目标文件夹中的 Contents.json，为每张图片添加暗色模式配置。 这一步完成之后，大部分浅色模式图片能够匹配到对应的暗黑模式图片并完成更新。（因尺寸、色彩空间、内容轻微差异等问题）未匹配到的图片会被记录到一个 Excel 文件中，供后续人工处理。 注：这一步使用 OpenCV 提供的模板匹配（Template Matching）方法进行图像相似度计算以建立新旧图片之间的关系。 人工补充未匹配图片目标，补充第一步中未能自动匹配的图片。 在第一步生成的 Excel 表格人工填写未匹配图片对应的暗黑模式图片路径，将补充完成的表格作为输入，使用脚本批量将这些图片添加到目标路径，并更新 Contents.json，为所有浅色模式图片都具备对应的暗黑模式版本。 扫描查找重复图片，清理项目中存在的重复图片。 使用脚本扫描项目文件，定位所有重复的暗黑模式图片。将重复的图片记录到一个 Excel 文件中，供后续人工校对。 删除重复图片并更新项目中引用的图片名称。 人工校对第三步生成的重复图片 Excel 表格，确认需要删除的图片。此后遍历项目中所有代码源文件，查找并替换引用的旧图片路径为新图片的路径。 4.3 其他图片资源 除了 assets 中的图片资源，我们还有两种资源： 本地图片资源：一些使用不规范的图片资源没有使用 assets 管理，而是直接把资源添加到工程文件夹目录，导致了这些资源无法根据系统外观自动切换。一种处理方案是在资源使用处手动添加两个版本的图片资源使其自动切换（UIImage.imageAsset的方式），更优的方案是将这些资源迁移到 assets 中统一管理。 网络图片资源：对于 url 资源，我们无法做到动态切换。这常见于一些用户自定义的图片、头像等，也有一些配置化的资源需要存在云端，在使用的时候才会拉取下来进行展示。对于这种情况，在我们与设计团队进行沟通之后，决定对于这些资源进行统一化处理，即在深色模式和浅色模式下都用同一张图片资源，这样就免去了动态切换的麻烦。在进行统一化处理的时候，需要注意图片的背景颜色、图片透明度的问题，同时如果需要在不同外观下具有不同的背景色，则背景色应该交由 App 进行绘制，再将图片叠加其上。 此外，除了单纯的图片资源，我们还有动画资源。 JSON 动画资源：目前我们团队采用的动画方案是 Lottie + JSON，显而易见地，这种方案并不支持在系统层面上根据外观自动切换。我们采用的方案是手动监听系统的外观模式切换，根据系统的外观更新对应的 JSON 以达成动画的深色模式或浅色模式更新。在处理一些与当前状态相关的动画效果的时候，需要注意动画切换时的流畅性。 GIF 动画资源：在一些老旧的业务代码中还存留着 GIF 动画资源。与 JSON 动画类似，我们需要监听系统的外观切换，手动更新动画。 5 颜色资源处理 根据官方指南，相较于以前的硬编码颜色色值的使用方式，支持深色模式的资源更适合使用语义化的名称，根据颜色的使用场景为其命名，配置好的颜色资源会自动适应当前的 App 外观。 在支持深色模式的场景下，颜色应该使用“颜色的场景名称”而不是“颜色的色值”。在这种定义推动下，我们“只需要”工程里用到的所有的颜色色值替换成语义化颜色名即可。 对于一个持续运营迭代了好几年的 App，这样子的颜色色值替换可不是简单的工作。在一个体量并不小的工程中，找出所有的颜色色值并替换会遇到下面这些问题： Swift/OC创建颜色的方法有很多种，对于这些五花八门的颜色使用方式，我们要怎么找到它们然后再一一替换成需要的资源？ 对于海量的颜色色值，我们势必采用批量处理的方式进行替换，如果仅使用 IDE 的 Find-Replace 方式进行替换效率太低，要如何提升效率并保证准确率？ 对于各种各样的业务及所用到的颜色色值，要怎么定义它们的一一对应关系？换句话说，原本的么处理？ 对于 VeSync 来说，业务形态决定了某一些板块会相对独立，在开发者对某一模块并不熟悉的情况下要怎么进行这一部分的适配工作？ 显然，量变产生质变，要人工逐个替换已经是不可能完成的工作了，通过脚本进行颜色替换就是自然而然选择了。以下就介绍一下颜色处理的方案和实践流程。 5.1 方案 在脚本替换之前，我们需要先建立我们的颜色资源库。 根据官方指南， 我们需要一个语义化的颜色资源库。这一部分工作由设计部门完成，他们需要为 App 内所用到的所有颜色色值增加对应深色模式的颜色色值，并为其命名，形成一套完整的语义化颜色资源。 在拿到语义化的颜色资源后，我们要将这些颜色资源导入到工程中。由于涉及到跨部门、跨工具的合作（Zeplin/Figma、Xcode/VSCode），这一部分并没办法用脚本处理，只能人工一个个颜色搬运到工程的 .xcassets 文件中。在辛苦搬运完成后，我们就可以使用脚本读取这些资源并使用它们了。 至此我们有了语义化的颜色资料库，那么接下来就是识别工程中的存量的硬编码的颜色代码，并进行替换了。虽然先前的问题中提到了硬编码色值的方式多种多样，但事实上这些编码方式总是可以穷举的。既然可以穷举，那我们就可以编写脚本进行批量处理。我们采用的方式是通过遍历源文件，以正则匹配的方式获取到硬编码色值的代码段及其对应的色值。 当有了颜色资料库、有了工程所用到的颜色，下一步要做的事情已经显而易见了。我们对比两者，将原本的硬编码色值的相关代码替换为语义化的颜色名代码。此外，为了处理一些“边界情况”，我们需要使用 Excel 表格记录下我们的替换结果，让开发人员能够有所凭依地进行开发和检查。 到这里为止，我们使用脚本适配深色模式的流程就已经基本构思完成，如下流程图所示： 1234567891011graph TBA(人工导入语义化颜色资源) ---&gt; B[脚本读取.xcassets中的颜色资源]B -- 输出 --&gt; C1(颜色代码)B ---&gt; D&#123;使用色值进行比对&#125;D --色值不同--&gt; D1(输出 error.xml)E(穷举颜色编码方式) ---&gt; F[识别、解析存量的硬编码颜色]F ---&gt; DD --色值相同--&gt; G[替换硬编码颜色为语义化颜色]G -- 输出 --&gt; H[工程源码替换]G -- 输出 --&gt; H1(记录success.xml)H ---&gt; I(替换完成，结束) 5.2 实施 接下来我们简单介绍一下具体的实践方式。 iOS 使用 .xcassets 的方式储存颜色资源，配置好的颜色资源如下图所示： 这一个个颜色资源本质上是Contents.json文件： text1234567891011121314151617181920212223242526272829303132333435363738&#123; &quot;colors&quot; : [ &#123; &quot;color&quot; : &#123; &quot;color-space&quot; : &quot;srgb&quot;, &quot;components&quot; : &#123; &quot;alpha&quot; : &quot;1.000&quot;, &quot;blue&quot; : &quot;0x89&quot;, &quot;green&quot; : &quot;0x66&quot;, &quot;red&quot; : &quot;0x00&quot; &#125; &#125;, &quot;idiom&quot; : &quot;universal&quot; &#125;, &#123; &quot;appearances&quot; : [ &#123; &quot;appearance&quot; : &quot;luminosity&quot;, &quot;value&quot; : &quot;dark&quot; &#125; ], &quot;color&quot; : &#123; &quot;color-space&quot; : &quot;srgb&quot;, &quot;components&quot; : &#123; &quot;alpha&quot; : &quot;1.000&quot;, &quot;blue&quot; : &quot;0x77&quot;, &quot;green&quot; : &quot;0x59&quot;, &quot;red&quot; : &quot;0x02&quot; &#125; &#125;, &quot;idiom&quot; : &quot;universal&quot; &#125; ], &quot;info&quot; : &#123; &quot;author&quot; : &quot;xcode&quot;, &quot;version&quot; : 1 &#125;&#125; 通过解析 json 中的components我们可以得到颜色名和色值的对应关系。需要注意的是，components中的色值可能存在不同的写法，这与xcassets文件中颜色的 Input Method有关。 在读取完语义化颜色后，我们会把这些资源输出为一个单独的模块。在这一步我们使用了一些模板代码，将解析到的语义化颜色名及其色值按照 swift 规范整理成我们需要的方法及其注释，如下所示，以便在业务代码中引用。 这些颜色读取的脚本和模板代码应该单独抽离出来或生成一个可执行文件，为后续项目的开发新增颜色创造便利条件。 text12345678910111213141516@objc public class VSColor: NSObject &#123;&#125;/// 语义化颜色public extension VSColor &#123; // MARK: - Auxiliary /// Light - 006689, 1.00 /// Dark - 025977, 1.00 @objc static func auxiliary_blue() -&gt; UIColor &#123; return color(named: &quot;auxiliary_blue&quot;) &#125; /// Light - 64EDC2, 1.00 /// Dark - 57CBA7, 1.00 @objc static func auxiliary_brilliant_green() -&gt; UIColor &#123; return color(named: &quot;auxiliary_brilliant_green&quot;) &#125; // ...&#125; 类似地，我们采用脚本读取工程中存量的硬编码颜色。对于各种各样的颜色编码方式，我们只能采用”比较笨”的穷举的方式，找到工程中使用的编码方式，采用字符串分割或者是正则匹配的方式提取到这一段代码块并解析色值，具体问题具体分析。这一步其实就是“玩转字符串”，相信大家一定很熟悉，笔者就不在这里献丑了。 事实上这一步需要处理的细节会想象中的更多，比如处理 swift、OC 的语法区别（没错，还有 OC 代码）；比如 RGBA 和 HEX 的写法需要区分和解析；比如处理浅色模式的同一个色值在深色模式下可能会有不同的色值，即同一个硬编码色值在不同的业务板块需要替换成不同的语义化颜色。 此外，我们除了需要记录提取到的代码块的源码、解析到的rgba值之外，还需要额外记录代码的文件位置和行数等有用信息，以便后续进行字符串替换。 放一个图让大家看看“穷举”到底有多少 接下来要做的事情就比较简单了，遍历两个数组（硬编码颜色、语义化颜色），使用他们的 rgba 值进行比对，如果硬编码颜色匹配到了对应的语义化的颜色名，则直接在源码中进行文件读写操作，替换为语义化颜色名，同时记录到 Excel 文件中。下面是这个功能的伪代码： text123456789101112131415Read color resources into vscolor_jsonIdentify and parse hardcoded colors into color_jsonFor each sheet in color_json For each line in sheet If line contains &quot;red value&quot;, &quot;green value&quot;, &quot;blue value&quot;, &quot;alpha value&quot;, and &quot;result&quot; is &quot;correct&quot; For each vscolor in vscolor_json If line&#x27;s color values match vscolor&#x27;s color values Get file_path, line_number, old_color Determine new_color based on sheet type Print replacement information Replace color code in file Exit loop Else Continue to next loop 写到这里，脚本的任务基本就完成了，这些脚本为我们提取并替换颜色，大幅度提高了工作效率，为程序员的头发作出了巨大贡献。 5.3 机器队VS人工队 VeSync App 是使用组件化的方式进行业务开发，在一个组件内的业务代码相对完整，他们的开发者对自己负责过的业务组件更加熟悉，但考虑到实际情况，这些开发者并没有很多时间投入到存量业务的深色模式适配项目中。面对这个问题，我们采用了脚本替换+人工校对+UI阶段性验收的方式进行项目开发，具体的开发流程如下 123456789101112131415161718192021sequenceDiagram autonumber participant UI as UI participant Dev as App开发-负责人 participant Bus as App开发-业务线 UI-&gt;&gt;Dev: 按模块出设计稿 Note right of Dev: 开始开发流程 Dev-&gt;&gt;Bus: 协调模块对应开发人员 Bus-&gt;&gt;Dev: 业务线提前告知介入时间 Dev-&gt;&gt;Dev: 1. 申请Zeplin/Figma权限&lt;br&gt;2. 申请相关开发仓库分支&lt;br&gt;3. 执行颜色替换脚本&lt;br&gt;4. 大致修正颜色 Dev-&gt;&gt;Bus: 业务线实际介入开发 Note right of Bus: 业务线进行校对&amp;开发工作 Bus-&gt;&gt;Dev: 开发完成，返回开发负责人 Dev-&gt;&gt;Dev: 代码合并、打包 Note right of Dev: 开发完成，准备审查 Dev-&gt;&gt;UI: 阶段性审查 UI-&gt;&gt;Dev: UI问题修正 Note right of UI: 根据审查结果进行调整 Dev-&gt;&gt;UI: 最终审查 Note right of UI: 确认无误，流程结束 对于上图的流程这里再做一些补充说明： App 开发-负责人： 申请分支：负责人会与业务线开发人员沟通，申请对应业务相关的仓库分支 执行脚本：在申请完分支以后，负责人会执行脚本，替换大部分颜色，保证各页面基本适配 大致修正颜色：对于一些特殊颜色，开发负责人会在业务线介入之前大致修正白色的使用（根据颜色的使用语境判断） App 开发-业务线 前告知介入时间：在介入的提前两天与负责人沟通 实际开发：对模块的每个页面逐个核对，修正遗漏掉的颜色等错误展示效果 按照上面的流程，深色模式的适配对于业务线的开发者来说，只需要如常执行他们的业务流程，指出并修复个别错误展示效果（颜色或图片），而工作量最大的颜色替换部分则由项目负责人使用脚本进行处理。在一个板块的适配完成后，会打包交付 UI、产品阶段性验收，验收完成后，开发再针对提出的 UI 问题进行修改。这样一来，我们就同时保证了开发的效率和准确率。 6 尾声 在探讨了深色模式的技术细节之后，我们不难发现，尽管其核心概念和实现方法在技术层面上并不复杂，但真正要将深色模式完美融入我们的应用中，却远非易事。对于已经上线并拥有一定用户基础的应用来说，如何在不破坏现有功能和用户体验的前提下，平滑过渡到深色模式，是一个需要精心策划和逐步实施的过程。虽然技术实现本身并不复杂，但要真正做到完美适配，却需要我们投入更多的精力和智慧。在未来，随着用户对个性化和舒适度要求的不断提高，深色模式无疑将成为应用中不可或缺的一部分。我们期待，通过不断的探索和实践，能够为用户带来更加丰富和舒适的使用体验。 感谢您的阅读，希望本文能够为您提供一些关于深色模式适配的有益见解和启发。如果您有任何疑问或建议，欢迎留言交流。","categories":[{"name":"Blog","slug":"Blog","permalink":"https://jiahaofang.github.io/categories/Blog/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://jiahaofang.github.io/tags/iOS/"}]},{"title":"Notion + Hexo 博客解决方案","slug":"Notion + Hexo 博客解决方案","date":"2025-04-01T18:12:00.000Z","updated":"2025-04-01T20:16:00.000Z","comments":true,"path":"Notion + Hexo 博客解决方案/","link":"","permalink":"https://jiahaofang.github.io/Notion%20+%20Hexo%20%E5%8D%9A%E5%AE%A2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"创作&amp;开发","text":"创作&amp;开发 Notion 使用 notion 进行内容创作 使用 notion database 进行知识库整理 本文使用 hexo 平台，可参考elog-hexo-template 创建数据库副本或增加必要属性到已有 Notion 数据库 Hexo 使用 Hexo 进行博客开发 使用git分支保存源码 因Github Page要求使用master分支作为发布网站的源代码，我们只能用master分支来保存hexo生成的静态网页，对于博客源码，可以新建一个source分支来存储。在github上打开Pages对应的仓库，也就是以”username.github.io”命名的仓库，然后建立一个source分支，仓库的默认分支改为保存源码的source分支，这样通过git clone拉取的就是source分支代码了。 根据自己喜好配置 Hexo 这里可以自行搜索，也可以参考《Hexo 相关记录》一文 仓库源码大致目录结构如下 1234567891011121314151617.├── README.md├── _config.landscape.yml├── _config.next.yml├── _config.yml├── db.json├── elog.cache.json├── elog.config.js├── hexo.sh├── node_modules├── package-lock.json├── package.json├── public├── scaffolds├── source├── themes└── time.txt CI/CD 本项目持续集成的路径为：notion ⇒ slack ⇒ pipedream ⇒ elog + github action Slack 注册 Slack 注册完成后创建工作区 ![image.png](../images/39b5b6f7aff90d3a40276068bc36f00e.png) 创建频道（channel） 添加应用 Notion 全部创建完成后如图 Notion 创建 automation，设置触发器 在数据库页面点击闪电按钮，可以创建 automation ，增加触发器以及执行器 根据自己喜好设置触发器，设置完成后如下 Pipedream 注册 创建 Project 创建 workflow 在 project 下创建workflow 设置 workflow 设置 workflow，触发器选择 Slack，选择New Message In Channels ，按照如下设置 ![image.png](../images/51ef693bc2dab2a08feb5d373debb903.png) ![image.png](../images/69e9cb0f6c83874a2091e07a199b5f5b.png) 增加 Python step 增加一个 Python Step，代码如下所示 123456789101112131415161718192021222324252627import osimport requestsimport jsondef handler(pd: &quot;pidedream&quot;): try: token = os.environ[&#x27;GITHUB_TOKEN&#x27;] user = &quot;github_username&quot; repo = &quot;github_repo&quot; event_type = &quot;deploy&quot; headers = &#123; &quot;User-Agent&quot;: &quot;@elog/serverless-api&quot;, &quot;Accept&quot;: &#x27;*/*&#x27;, &quot;Authorization&quot;: f&quot;token &#123;token&#125;&quot;, &#125; response = requests.post( f&quot;https://api.github.com/repos/&#123;user&#125;/&#123;repo&#125;/dispatches&quot;, headers=headers, data=json.dumps(&#123;&quot;event_type&quot;: event_type&#125;) ) # response.raise_for_status() print(response.text, response.json()) return &#123;&quot;message&quot;: response.json() or &#x27;Success!&#x27;&#125; except Exception as e: print(e) 设置完成后如图所示 配置环境变量，用于 code 中使用，在环境中通过 os.environ['your_token']来使用 Elog + Github Action 在博客文件夹根目录配置 Elog 参考官方文档进行操作，其余相关配置以官方文档为准。 项目添加 workflow 配置 在项目文件夹根目录增加 github actions 相关配置文件.github/workflows/main.yaml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283name: Deploy To Github Pageson: # 允许手动push触发 push: branches: # 存放源码的分支 - master # 允许外部仓库事件触发 repository_dispatch: types: # api中的event_type就是这个 - deployjobs: build: runs-on: ubuntu-latest steps: - name: 检查分支 uses: actions/checkout@master - name: 安装node环境 uses: actions/setup-node@master with: node-version: &quot;16.x&quot; - name: 安装依赖 run: | export TZ=&#x27;Asia/Shanghai&#x27; npm install --prod - name: 拉取语雀/Notion的文章 env: # 语雀相关环境变量 YUQUE_TOKEN: $&#123;&#123; secrets.YUQUE_TOKEN &#125;&#125; YUQUE_LOGIN: $&#123;&#123; secrets.YUQUE_LOGIN &#125;&#125; YUQUE_REPO: $&#123;&#123; secrets.YUQUE_REPO &#125;&#125; # Notion相关环境变量 NOTION_TOKEN: $&#123;&#123; secrets.NOTION_TOKEN &#125;&#125; NOTION_DATABASE_ID: $&#123;&#123; secrets.NOTION_DATABASE_ID &#125;&#125; # 图床相关环境变量，以腾讯云COS为例 COS_SECRET_ID: $&#123;&#123; secrets.COS_SECRET_ID &#125;&#125; COS_SECRET_KEY: $&#123;&#123; secrets.COS_SECRET_KEY &#125;&#125; COS_IMAGE_BUCKET: $&#123;&#123; secrets.COS_IMAGE_BUCKET &#125;&#125; COS_IMAGE_REGION: $&#123;&#123; secrets.COS_IMAGE_REGION &#125;&#125; run: | # 对应package.json中的script.sync npm run sync - name: 配置Git用户名邮箱 run: | git config --global user.name &quot;xxx&quot; git config --global user.email &quot;xxx@xx.com&quot; - name: 提交yuque拉取的文章到GitHub仓库 run: | echo `date +&quot;%Y-%m-%d %H:%M:%S&quot;` begin &gt; time.txt git add . git commit -m &quot;更新文档&quot; -a - name: 推送文章到仓库 uses: ad-m/github-push-action@master with: github_token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; - name: 生成静态文件 run: | # 对应package.json中的script.build npm run build - name: 部署到Github Pages uses: peaceiris/actions-gh-pages@v4 with: # 这里使用 github token personal_token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; # hexo 设置为这个路径 publish_dir: ./public external_repository: JiaHaoFang/JiaHaoFang.github.io # 存放 github page 静态文件的分支 publish_branch: master commit_message: $&#123;&#123; github.event.head_commit.message &#125;&#125; 添加环境变量 根据 Elog 文档获取对应的环境变量，添加到 github 仓库设置 配置Actions 执行权限 在仓库的 Settings-Actions-Genaral-Workflow permissions 中配置执行权限 Github Page 设置 设置 Github Page 的部署分支（区分与源代码分支），这里本人使用 master 部署静态页面，使用 source 分支存放源码 执行效果 Slack pipedream Github Actions","categories":[{"name":"Blog","slug":"Blog","permalink":"https://jiahaofang.github.io/categories/Blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://jiahaofang.github.io/tags/hexo/"},{"name":"elog","slug":"elog","permalink":"https://jiahaofang.github.io/tags/elog/"},{"name":"notion","slug":"notion","permalink":"https://jiahaofang.github.io/tags/notion/"}]},{"title":"iOS代码发布为组件","slug":"iOS代码发布为组件","date":"2025-04-01T18:01:00.000Z","updated":"2025-04-01T19:29:00.000Z","comments":true,"path":"iOS代码发布为组件/","link":"","permalink":"https://jiahaofang.github.io/iOS%E4%BB%A3%E7%A0%81%E5%8F%91%E5%B8%83%E4%B8%BA%E7%BB%84%E4%BB%B6/","excerpt":"1 前期准备","text":"1 前期准备 1.1 远程仓库 准备好两个远程仓库，在GitHub上创建即可； 权限建议为public 用来存放源码的仓库，该仓库用来存放自己编写的组件的源码，其应为正确的目录结构，如何模板创建下文详细说； text1&lt;https://github.com/JiaHaoFang/SFAPPRealTimeLogCaughter.git&gt; 用来存放组件的仓库，相当于xxxRepo、CocoaPods/Spec，是自己私有的组件仓库，用来存放.podspec文件； text1&lt;https://github.com/JiaHaoFang/SFPodRepo.git&gt; 注：该仓库非必要，可以使用官方仓库，此处为了熟悉流程使用自己创建的仓库 1.2 本地代码 由于该组件为一个完整工程作为组件发布，需要抽离 保证需要发布为组件的工程，其核心功能完整，去耦，能够实现核心功能的抽离 保证编译可通过，同时核心功能具备可移植性 2 本地目录创建 2.1 创建私有Repo目录 在～/.cocoapods/repo中能看到本地有的repo仓库，其中cocoapods为官方仓库，trunk也是官方仓库（历史遗留问题）；xxxRepo为公司私有仓库。 该步骤将创建私人仓库SFRepo，作用类似上文的官方仓库，后续将用来存放个人的组件。 或者也可以选择发布到官方仓库。 命令 1pod repo add SFPod &lt;https://github.com/JiaHaoFang/SFPodRepo.git&gt; 创建完成之后可通过命令查看目录结构 1open ~/.cocoapods/repos/SFPod 2.2 创建个人组件目录 发布的组件需要按照Cocoapod严格遵守官方给出的目录结构，官方给出了命令可以直接生成模版 1pod lib create SFAPPRealTimeLogCaughter 过程中终端会向我们提出一系列问题，包括开发语言是OC还是Swift，demo程序，测试框架，界面测试。我选择了包含demo程序，没有测试框架. 生成模版后可以使用tree命令查看该文件夹下的目录结构 2.3 编辑模版 在2.2创建的公共模版就是组件的模板，我们需要将我们的代码添加进去将其作为自己的组件 我们需要发布的组件核心功能代码存放在/SFPod/Pod/Classes文件夹中 另外在Example中编写Demo测试自己的组件是否能正常工作，点击.xcworkspace可以作为一个完整工程运行 在写Example的时候，如果修改了Classes中文件的，需要pod install一下，将组件在自己的Demo中更新一下 2.4 编辑.podspec文件 自行Google 3 发布组件 如果上面的步骤完成了，恭喜，完成了一半 3.1 校验 当2中的步骤全部完成，我们可以使用下面的命令检验自己组件代码的合法性（主要是检验.podspec文件） 123456pod lib lint# 只从本地验证你的pod能否通过验证。pod spec lint# 从本地和远程验证你的pod能否通过验证，建议使用这个--allow-warnings# 如何库代码中有警告导致通不过验证。加上这个忽略警告 3.2 提交源码 提交源码到个人仓库 text12345git add -agit commit -m &quot;xxx&quot;git pushgit tag 0.1.0git push --tags 3.3 发布组件到个人Repo 使用命令将.podspec文件添加到~/.cocoapods/repos/SFPod中，同时也发布到远程仓库 1pod repo push SFPod SFAPPRealTimeLogCaughter.podspec 执行完该步骤后， ~/.cocoapods/repos/SFPod会新增对应版本的.podspec文件 3.4 查询 搜索组件库 1pod search SFAPPRealTimeLogCaughter 搜索到了说明安装成功 4 使用组件 在Podfile文件新增源 12source &#x27;&lt;https://github.com/JiaHaoFang/SFPodRepo.git&gt;&#x27;source &#x27;&lt;https://github.com/CocoaPods/Specs.git&gt;&#x27; 添加pod 1pod &#x27;SFAPPRealTimeLogCaughter&#x27; 上面两项可以合起来写，合不起来。。。 执行 pod install 运行代码 参考资料：https://www.jianshu.com/p/103a6f0bf3a4","categories":[{"name":"Coding","slug":"Coding","permalink":"https://jiahaofang.github.io/categories/Coding/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://jiahaofang.github.io/tags/iOS/"}]},{"title":"Hexo 相关记录","slug":"Hexo 相关记录","date":"2025-04-01T17:58:00.000Z","updated":"2025-04-01T18:06:00.000Z","comments":true,"path":"Hexo 相关记录/","link":"","permalink":"https://jiahaofang.github.io/Hexo%20%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95/","excerpt":"使用git分支保存源码","text":"使用git分支保存源码 拉取分支 因Github Page要求使用master分支作为发布网站的源代码，我们只能用master分支来保存hexo生成的静态网页，对于博客源码，可以新建一个source分支来存储。在github上打开Pages对应的仓库，也就是以”username.github.io”命名的仓库，然后建立一个source分支，仓库的默认分支改为保存源码的source分支，这样通过git clone拉取的就是source分支代码了。 1git clone &lt;https://github.com/JiaHaoFang/JiaHaoFang.github.io.git&gt; 配置环境 1234# 安装hexonpm install hexo# git支持npm install hexo-deployer-git -save 添加next主题配置 1git clone &lt;https://github.com/theme-next/hexo-theme-next.git&gt; themes/next 显示摘要 text12# 显示摘要npm install hexo-excerpt --save 用typora写作 markdown语法支持 使用typora作为语法编辑器，使用插件使网页能够支持markdown的编辑格式 安装库 123# markdown语法支持npm uni hexo-renderer-marked --savenpm i @upupming/hexo-renderer-markdown-it-plus --save 使用 在hexo站点配置文件_config.yml中添加如下配置，详细配置: 1234567891011# Markdown configmarkdown_it_plus: highlight: true html: true xhtmlOut: true breaks: true langPrefix: linkify: true typographer: quotes: “”‘’ pre_class: highlight 图片链接 为了与typora写作，使网页能够直接渲染typora编辑的markdown文档，需要在typora中设置图片保存在./$${filename}下，安装该插件即可（该插件md写着是为了与typora共同使用而开发） text12# 图片链接npm install hexo-image-link --save 文章置顶 text123# 添加文章置顶功能，未使用npm uninstall hexo-generator-index --savenpm install hexo-generator-index-pin-top --save 安装后在文章顶部增加字段top: true即可 页脚增加网站运行时间统计(NexT8.0 以下) 找到 \\\\themes\\\\next\\\\layout\\\\_partials\\\\ 下面的 footer.swig 文件 在合适的位置添加下面代码（通过运行调试，查看运行时间出现的位置）（45行） text12345678910111213141516171819202122232425262728293031323334353637383940&lt;!--添加运行时间--&gt;&lt;span id=&quot;sitetime&quot;&gt;&lt;/span&gt;&lt;script language=javascript&gt; function siteTime()&#123; window.setTimeout(&quot;siteTime()&quot;, 1000); var seconds = 1000; var minutes = seconds * 60; var hours = minutes * 60; var days = hours * 24; var years = days * 365; var today = new Date(); var todayYear = today.getFullYear(); var todayMonth = today.getMonth()+1; var todayDate = today.getDate(); var todayHour = today.getHours(); var todayMinute = today.getMinutes(); var todaySecond = today.getSeconds(); /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳) year - 作为date对象的年份，为4位年份值 month - 0-11之间的整数，做为date对象的月份 day - 1-31之间的整数，做为date对象的天数 hours - 0(午夜24点)-23之间的整数，做为date对象的小时数 minutes - 0-59之间的整数，做为date对象的分钟数 seconds - 0-59之间的整数，做为date对象的秒数 microseconds - 0-999之间的整数，做为date对象的毫秒数 */ var t1 = Date.UTC(2022,02,21,13,30,00); //北京时间2018-2-13 00:00:00 var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond); var diff = t2-t1; var diffYears = Math.floor(diff/years); var diffDays = Math.floor((diff/days)-diffYears*365); var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours); var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes); var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds); document.getElementById(&quot;sitetime&quot;).innerHTML=&quot; 已运行&quot;+/*diffYears+&quot; 年 &quot;+*/diffDays+&quot; 天 &quot;+diffHours+&quot; 小时 &quot;+diffMinutes+&quot; 分钟 &quot;+diffSeconds+&quot; 秒&quot;; &#125; siteTime();&lt;/script&gt;&lt;!--添加运行时间--&gt; 页脚增加网站运行时间统计(NexT8.0 以上) 找到 themes/next/layout/_partials/footer.njk文件 在末尾加入以下代码 text123456789101112131415161718192021&lt;!-- &lt;br /&gt; --&gt;&lt;!-- 网站运行时间的设置 --&gt;&lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;&lt;!-- &lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt; --&gt;&lt;script&gt;var now = new Date();function createtime() &#123; var grt= new Date(&quot;02/21/2022 13:30:00&quot;);//(2022,02,21,13,30,00) now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = &quot;0&quot; + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = &quot;0&quot; + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = &quot;0&quot; + snum;&#125; // var times = document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;; document.getElementById(&quot;timeDate&quot;).innerHTML = &quot;本站已安全运行 &quot;+dnum+&quot; 天 &quot;+hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;;&#125;setInterval(&quot;createtime()&quot;,250);&lt;/script&gt; 搜索引擎支持 各搜索引擎网站管理员中心 Google：https://www.google.com/webmasters/tools bing：https://www.bing.com/webmasters/home 向搜索引擎提交站点 以Google为例 修改themes/next/_config.yml文件： 123# Google Webmaster tools verification.# See: &lt;https://www.google.com/webmasters&gt;google_site_verification: xxxxxxxxxx 提交网站地图 提交网站地图加快索引 安装插件sitemap text1npm install hexo-generator-sitemap –save 在themes/next/_config.yml中修改： 123456789menu:home: / || fa fa-hometags: /tags/ || fa fa-tagscategories: /categories/ || fa fa-tharchives: /archives/ || fa fa-archiveabout: /about/ || fa fa-user#schedule: /schedule/ || fa fa-calendarsitemap: /sitemap.xml || fa fa-sitemap#commonweal: /404/ || fa fa-heartbeat 生成静态网页，上传，然后在对应搜索引擎的webmasters中添加站点地图的地址即可 验证是否被检索 以GitHub Pages为例，新建的GitHub Pages是没有被谷歌检索的。在谷歌搜索栏中输入如下信息进行检索： 1site: jiahaofang.github.io 本地搜索功能 在根目录执行命令 1npm install hexo-generator-searchdb --save 配置 hexo 的_config.yml文件 在文件末尾新增配置项 12345search: path: search.xml field: post format: html limit: 10000 配置 NexT 主题的 _config.yml（根据 next 文档，应为/_config.next.yml） 123# Local searchlocal_search: enable: true","categories":[{"name":"Blog","slug":"Blog","permalink":"https://jiahaofang.github.io/categories/Blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://jiahaofang.github.io/tags/hexo/"}]},{"title":"Notion示例文章","slug":"Notion示例文章","date":"2025-03-31T23:35:00.000Z","updated":"2025-04-01T18:05:00.000Z","comments":true,"path":"/notion-example/","link":"","permalink":"https://jiahaofang.github.io/notion-example/","excerpt":"Notion-Markdown","text":"Notion-Markdown Notion示例文章源地址 行内样式 加粗 斜体 下划线 删除线 行内代码 const a = 123 行内公式，在Vitepress会报错，不做演示 红色的文字 蓝色的文字背景 绿色的块背景 Basic block（基本块） Notion示例文章的子页面 Notion示例文章的子页面 表格标题 备注 测试1 啊大大 测试2 const a = 123 无序列表 有序列表：事物按规律变化，也有一种不可避免的性质．这种性质就叫做必然性 事物的必然性，是事物本身的性质（我们反对宿命论的是其认为这一切是受神明的支配，而不是反对事物发展中存在的不可避免的性质的事实） 第三级别列表 第三级别列表 其决定于它自己本身发展的情况和周围的条件 第三级别列表 第三级别列表 折叠块：点击展开【一级】 点击展开【二级】 点击展开【三级】 内容文本 123 引用块 引用换行 引用换行 引用 2 引用 2 换行 👏 标注文本：Elog 0.4.0-beta.7 发布了！ 开放式跨平台博客解决方案，随意组合写作平台和部署平台 帮助导航👇 ❓ Elog能干什么 🚀 快速开始 Media（媒体） bookmark 46_1677164223.mp4 12345pwd=&#x27;123456&#x27;print(f&quot;password=&#123;pwd!r&#125;&quot;)## output:#password=&#x27;123456&#x27; example.txt DataBase（数据库） 数据库 AI block API不支持，会报错Block type ai_block is not supported via the API. Advanced block（高级块） f([1+{x,y}(xy+yx)(u+1)+a]3/2)(行标)f\\left(\\left[\\frac{1+\\{x, y\\}}{\\left(\\frac{x}{y}+\\frac{y}{x}\\right)(u+1)}+a\\right]^{3 / 2}\\right)\\tag{行标} f⎝⎜⎛​⎣⎡​(yx​+xy​)(u+1)1+{x,y}​+a⎦⎤​3/2⎠⎟⎞​(行标) Notion示例文章的同步块 折叠一级标题 ## 折叠二级标题 折叠内容 两列分栏（左） [ ] 左侧书写 两列分栏（右） [ ] 右侧书写 123graph LR;Mermaid思维导图--&gt;思维导图Mermaid思维导图--&gt;研发 @Anonymous Untitled 2023-04-26 🚀🔥🐸 Embeds（嵌入） 嵌入网页 embed","categories":[{"name":"Blog","slug":"Blog","permalink":"https://jiahaofang.github.io/categories/Blog/"}],"tags":[{"name":"notion","slug":"notion","permalink":"https://jiahaofang.github.io/tags/notion/"}]}],"categories":[{"name":"Coding","slug":"Coding","permalink":"https://jiahaofang.github.io/categories/Coding/"},{"name":"Blog","slug":"Blog","permalink":"https://jiahaofang.github.io/categories/Blog/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://jiahaofang.github.io/tags/iOS/"},{"name":"hexo","slug":"hexo","permalink":"https://jiahaofang.github.io/tags/hexo/"},{"name":"elog","slug":"elog","permalink":"https://jiahaofang.github.io/tags/elog/"},{"name":"notion","slug":"notion","permalink":"https://jiahaofang.github.io/tags/notion/"}]}