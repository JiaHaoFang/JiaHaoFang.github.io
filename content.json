{"meta":{"title":"阿告今天学习了吗","subtitle":"","description":"","author":"阿告2426","url":"https://jiahaofang.github.io","root":"/"},"pages":[{"title":"","date":"2025-04-01T10:07:44.176Z","updated":"2025-04-01T10:07:44.176Z","comments":true,"path":"404.html","permalink":"https://jiahaofang.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2025-04-01T10:07:44.176Z","updated":"2025-04-01T10:07:44.176Z","comments":true,"path":"about/index.html","permalink":"https://jiahaofang.github.io/about/index.html","excerpt":"","text":"About me"},{"title":"tags","date":"2014-12-22T12:39:04.000Z","updated":"2025-04-01T10:07:44.177Z","comments":true,"path":"tags/index.html","permalink":"https://jiahaofang.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-02-22T11:29:09.000Z","updated":"2025-04-01T10:07:44.177Z","comments":true,"path":"categories/index.html","permalink":"https://jiahaofang.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"iOS代码发布为组件","slug":"iOS代码发布为组件","date":"2025-04-01T18:01:00.000Z","updated":"2025-04-01T18:06:00.000Z","comments":true,"path":"iOS代码发布为组件/","link":"","permalink":"https://jiahaofang.github.io/iOS%E4%BB%A3%E7%A0%81%E5%8F%91%E5%B8%83%E4%B8%BA%E7%BB%84%E4%BB%B6/","excerpt":"1 前期准备","text":"1 前期准备 1.1 远程仓库 准备好两个远程仓库，在GitHub上创建即可； 权限建议为public 用来存放源码的仓库，该仓库用来存放自己编写的组件的源码，其应为正确的目录结构，如何模板创建下文详细说； text1&lt;https://github.com/JiaHaoFang/SFAPPRealTimeLogCaughter.git&gt; 用来存放组件的仓库，相当于xxxRepo、CocoaPods/Spec，是自己私有的组件仓库，用来存放.podspec文件； text1&lt;https://github.com/JiaHaoFang/SFPodRepo.git&gt; 注：该仓库非必要，可以使用官方仓库，此处为了熟悉流程使用自己创建的仓库 1.2 本地代码 由于该组件为一个完整工程作为组件发布，需要抽离 保证需要发布为组件的工程，其核心功能完整，去耦，能够实现核心功能的抽离 保证编译可通过，同时核心功能具备可移植性 2 本地目录创建 2.1 创建私有Repo目录 在～/.cocoapods/repo中能看到本地有的repo仓库，其中cocoapods为官方仓库，trunk也是官方仓库（历史遗留问题）；xxxRepo为公司私有仓库。 该步骤将创建私人仓库SFRepo，作用类似上文的官方仓库，后续将用来存放个人的组件。 或者也可以选择发布到官方仓库。 命令 1pod repo add SFPod &lt;https://github.com/JiaHaoFang/SFPodRepo.git&gt; 创建完成之后可通过命令查看目录结构 1open ~/.cocoapods/repos/SFPod 2.2 创建个人组件目录 发布的组件需要按照Cocoapod严格遵守官方给出的目录结构，官方给出了命令可以直接生成模版 1pod lib create SFAPPRealTimeLogCaughter 过程中终端会向我们提出一系列问题，包括开发语言是OC还是Swift，demo程序，测试框架，界面测试。我选择了包含demo程序，没有测试框架. 生成模版后可以使用tree命令查看该文件夹下的目录结构 2.3 编辑模版 在2.2创建的公共模版就是组件的模板，我们需要将我们的代码添加进去将其作为自己的组件 我们需要发布的组件核心功能代码存放在/SFPod/Pod/Classes文件夹中 另外在Example中编写Demo测试自己的组件是否能正常工作，点击.xcworkspace可以作为一个完整工程运行 在写Example的时候，如果修改了Classes中文件的，需要pod install一下，将组件在自己的Demo中更新一下 2.4 编辑.podspec文件 自行Google 3 发布组件 如果上面的步骤完成了，恭喜，完成了一半 3.1 校验 当2中的步骤全部完成，我们可以使用下面的命令检验自己组件代码的合法性（主要是检验.podspec文件） 123456pod lib lint# 只从本地验证你的pod能否通过验证。pod spec lint# 从本地和远程验证你的pod能否通过验证，建议使用这个--allow-warnings# 如何库代码中有警告导致通不过验证。加上这个忽略警告 3.2 提交源码 提交源码到个人仓库 text12345git add -agit commit -m &quot;xxx&quot;git pushgit tag 0.1.0git push --tags 3.3 发布组件到个人Repo 使用命令将.podspec文件添加到~/.cocoapods/repos/SFPod中，同时也发布到远程仓库 1pod repo push SFPod SFAPPRealTimeLogCaughter.podspec 执行完该步骤后， ~/.cocoapods/repos/SFPod会新增对应版本的.podspec文件 3.4 查询 搜索组件库 1pod search SFAPPRealTimeLogCaughter 搜索到了说明安装成功 4 使用组件 在Podfile文件新增源 12source &#x27;&lt;https://github.com/JiaHaoFang/SFPodRepo.git&gt;&#x27;source &#x27;&lt;https://github.com/CocoaPods/Specs.git&gt;&#x27; 添加pod 1pod &#x27;SFAPPRealTimeLogCaughter&#x27; 上面两项可以合起来写，合不起来。。。 执行 pod install 运行代码 参考资料：https://www.jianshu.com/p/103a6f0bf3a4","categories":[{"name":"Coding","slug":"Coding","permalink":"https://jiahaofang.github.io/categories/Coding/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://jiahaofang.github.io/tags/iOS/"}]},{"title":"Hexo 相关记录","slug":"Hexo 相关记录","date":"2025-04-01T17:58:00.000Z","updated":"2025-04-01T18:06:00.000Z","comments":true,"path":"Hexo 相关记录/","link":"","permalink":"https://jiahaofang.github.io/Hexo%20%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95/","excerpt":"使用git分支保存源码","text":"使用git分支保存源码 拉取分支 因Github Page要求使用master分支作为发布网站的源代码，我们只能用master分支来保存hexo生成的静态网页，对于博客源码，可以新建一个source分支来存储。在github上打开Pages对应的仓库，也就是以”username.github.io”命名的仓库，然后建立一个source分支，仓库的默认分支改为保存源码的source分支，这样通过git clone拉取的就是source分支代码了。 1git clone &lt;https://github.com/JiaHaoFang/JiaHaoFang.github.io.git&gt; 配置环境 1234# 安装hexonpm install hexo# git支持npm install hexo-deployer-git -save 添加next主题配置 1git clone &lt;https://github.com/theme-next/hexo-theme-next.git&gt; themes/next 显示摘要 text12# 显示摘要npm install hexo-excerpt --save 用typora写作 markdown语法支持 使用typora作为语法编辑器，使用插件使网页能够支持markdown的编辑格式 安装库 123# markdown语法支持npm uni hexo-renderer-marked --savenpm i @upupming/hexo-renderer-markdown-it-plus --save 使用 在hexo站点配置文件_config.yml中添加如下配置，详细配置: 1234567891011# Markdown configmarkdown_it_plus: highlight: true html: true xhtmlOut: true breaks: true langPrefix: linkify: true typographer: quotes: “”‘’ pre_class: highlight 图片链接 为了与typora写作，使网页能够直接渲染typora编辑的markdown文档，需要在typora中设置图片保存在./$${filename}下，安装该插件即可（该插件md写着是为了与typora共同使用而开发） text12# 图片链接npm install hexo-image-link --save 文章置顶 text123# 添加文章置顶功能，未使用npm uninstall hexo-generator-index --savenpm install hexo-generator-index-pin-top --save 安装后在文章顶部增加字段top: true即可 页脚增加网站运行时间统计(NexT8.0 以下) 找到 \\\\themes\\\\next\\\\layout\\\\_partials\\\\ 下面的 footer.swig 文件 在合适的位置添加下面代码（通过运行调试，查看运行时间出现的位置）（45行） text12345678910111213141516171819202122232425262728293031323334353637383940&lt;!--添加运行时间--&gt;&lt;span id=&quot;sitetime&quot;&gt;&lt;/span&gt;&lt;script language=javascript&gt; function siteTime()&#123; window.setTimeout(&quot;siteTime()&quot;, 1000); var seconds = 1000; var minutes = seconds * 60; var hours = minutes * 60; var days = hours * 24; var years = days * 365; var today = new Date(); var todayYear = today.getFullYear(); var todayMonth = today.getMonth()+1; var todayDate = today.getDate(); var todayHour = today.getHours(); var todayMinute = today.getMinutes(); var todaySecond = today.getSeconds(); /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳) year - 作为date对象的年份，为4位年份值 month - 0-11之间的整数，做为date对象的月份 day - 1-31之间的整数，做为date对象的天数 hours - 0(午夜24点)-23之间的整数，做为date对象的小时数 minutes - 0-59之间的整数，做为date对象的分钟数 seconds - 0-59之间的整数，做为date对象的秒数 microseconds - 0-999之间的整数，做为date对象的毫秒数 */ var t1 = Date.UTC(2022,02,21,13,30,00); //北京时间2018-2-13 00:00:00 var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond); var diff = t2-t1; var diffYears = Math.floor(diff/years); var diffDays = Math.floor((diff/days)-diffYears*365); var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours); var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes); var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds); document.getElementById(&quot;sitetime&quot;).innerHTML=&quot; 已运行&quot;+/*diffYears+&quot; 年 &quot;+*/diffDays+&quot; 天 &quot;+diffHours+&quot; 小时 &quot;+diffMinutes+&quot; 分钟 &quot;+diffSeconds+&quot; 秒&quot;; &#125; siteTime();&lt;/script&gt;&lt;!--添加运行时间--&gt; 页脚增加网站运行时间统计(NexT8.0 以上) 找到 themes/next/layout/_partials/footer.njk文件 在末尾加入以下代码 text123456789101112131415161718192021&lt;!-- &lt;br /&gt; --&gt;&lt;!-- 网站运行时间的设置 --&gt;&lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;&lt;!-- &lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt; --&gt;&lt;script&gt;var now = new Date();function createtime() &#123; var grt= new Date(&quot;02/21/2022 13:30:00&quot;);//(2022,02,21,13,30,00) now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = &quot;0&quot; + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = &quot;0&quot; + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = &quot;0&quot; + snum;&#125; // var times = document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;; document.getElementById(&quot;timeDate&quot;).innerHTML = &quot;本站已安全运行 &quot;+dnum+&quot; 天 &quot;+hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;;&#125;setInterval(&quot;createtime()&quot;,250);&lt;/script&gt; 搜索引擎支持 各搜索引擎网站管理员中心 Google：https://www.google.com/webmasters/tools bing：https://www.bing.com/webmasters/home 向搜索引擎提交站点 以Google为例 修改themes/next/_config.yml文件： 123# Google Webmaster tools verification.# See: &lt;https://www.google.com/webmasters&gt;google_site_verification: xxxxxxxxxx 提交网站地图 提交网站地图加快索引 安装插件sitemap text1npm install hexo-generator-sitemap –save 在themes/next/_config.yml中修改： 123456789menu:home: / || fa fa-hometags: /tags/ || fa fa-tagscategories: /categories/ || fa fa-tharchives: /archives/ || fa fa-archiveabout: /about/ || fa fa-user#schedule: /schedule/ || fa fa-calendarsitemap: /sitemap.xml || fa fa-sitemap#commonweal: /404/ || fa fa-heartbeat 生成静态网页，上传，然后在对应搜索引擎的webmasters中添加站点地图的地址即可 验证是否被检索 以GitHub Pages为例，新建的GitHub Pages是没有被谷歌检索的。在谷歌搜索栏中输入如下信息进行检索： 1site: jiahaofang.github.io 本地搜索功能 在根目录执行命令 1npm install hexo-generator-searchdb --save 配置 hexo 的_config.yml文件 在文件末尾新增配置项 12345search: path: search.xml field: post format: html limit: 10000 配置 NexT 主题的 _config.yml（根据 next 文档，应为/_config.next.yml） 123# Local searchlocal_search: enable: true","categories":[{"name":"Blog","slug":"Blog","permalink":"https://jiahaofang.github.io/categories/Blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://jiahaofang.github.io/tags/hexo/"}]},{"title":"Notion-Hexo 的 Elog 配置详解","slug":"Notion-Hexo 的 Elog 配置详解","date":"2025-03-31T23:35:00.000Z","updated":"2025-04-01T18:05:00.000Z","comments":true,"path":"/notion-notice/","link":"","permalink":"https://jiahaofang.github.io/notion-notice/","excerpt":"前言","text":"前言 在使用 Elog 同步Notion 上的文档时，因为是将富文本向下转成 markdown，会有很多样式损失。这是由于 markdown 样式集合＜ Notion 样式集合。所以在 Notion 上书写时，得按照 markdown 支持的样式进行写作。 可以在这里 看到 Notion 文档被导出为 markdown 时的样式损失程度 如果你不能接受样式损失，可能 markdown 并不适合你，隔壁 NotionNext 可能更适合你搭建博客。 Notion 格式注意点 不要使用 markdown 不支持的样式/语法 例如字体颜色、多级折叠块、书签、数据库、嵌入等。导出为 markdown 都不能正常展示。 适当使用 markdown 形式的超链接 在文档中使用markdown 形式的超链接可以解决部分路由问题，例如链接Notion文档的超链接会被自动处理为非完整路径，或者手动链接到某个相对路由，可以使用以下方式解决 text12// 使用[]() markdown 超链接语法点击 [下一篇](/notion/deploy-platform) 继续配置部署平台 请勿上传视频、文件到 Notion 文档 Elog 还暂不支持将Notion 中的视频、文件暂不支持上传到图床。如果下载到本地，短期内能访问，但因为 notion 的链接具有时效性，一般是一个小时，之后就不能查看了。 Elog 配置详解 参考Elog 文档，本博客的 Elog 的配置如下： 12345678910111213141516171819202122232425262728293031module.exports = &#123; write: &#123; platform: &#x27;notion&#x27;, notion: &#123; token: process.env.NOTION_TOKEN, databaseId: process.env.NOTION_DATABASE_ID, filter: &#123; property: &#x27;status&#x27;, select: &#123; equals: &#x27;已发布&#x27; &#125;&#125; &#125; &#125;, deploy: &#123; platform: &#x27;local&#x27;, local: &#123; outputDir: &#x27;./source/_posts&#x27;, filename: &#x27;title&#x27;, format: &#x27;markdown&#x27;, frontMatter: &#123; enable: true, include: [&#x27;categories&#x27;, &#x27;tags&#x27;, &#x27;title&#x27;, &#x27;date&#x27;, &#x27;updated&#x27;, &#x27;permalink&#x27;, &#x27;cover&#x27;, &#x27;description&#x27;] &#125;, formatExt: &#x27;./format-image.js&#x27;, &#125; &#125;, image: &#123; enable: true, platform: &#x27;local&#x27;, local: &#123; outputDir: &#x27;./source/images&#x27;, prefixKey: &#x27;/images&#x27; &#125; &#125;,&#125; Notion 配置 根据 Hexo 的 FrontMatter 配置文档，和 Butterfly主题的 FrontMatter 配置文档，可以将需要的参数作为 notion 数据库的字段来设置。一般来说，主题的 FrontMatter 为 Hexo在一些基础字段是共用的。 permalink为文档的永久链接，例如https://notion-hexo.vercel.app/notion-hexo/，注意记得在结尾加上/ categories为文档的分类 tags 为文档的标签 description为主题配置中可选的文档描述 12345notion: &#123; token: process.env.NOTION_TOKEN, databaseId: process.env.NOTION_DATABASE_ID, filter: &#123; property: &#x27;status&#x27;, select: &#123; equals: &#x27;已发布&#x27; &#125;&#125;,&#125; token为 Notion Token，可从此处获取 databaseId为数据库的 ID，可从此处获取 filter表示 Elog 将下载 notion 数据库属性为status=已发布的文档 本地配置 12345678910local: &#123; outputDir: &#x27;./source/_posts&#x27;, filename: &#x27;title&#x27;, format: &#x27;markdown&#x27;, frontMatter: &#123; enable: true, include: [&#x27;categories&#x27;, &#x27;tags&#x27;, &#x27;title&#x27;, &#x27;date&#x27;, &#x27;updated&#x27;, &#x27;permalink&#x27;, &#x27;cover&#x27;, &#x27;description&#x27;] &#125;, formatExt: &#x27;./format-image.js&#x27;,&#125; outputDir表示文档的存放位置为项目根目录下的source/_posts文件夹中 filename表示文档将以数据库的 title 字段命名，也就是文档名 format表示文档将以 markdown 的形式保存 frontMatter.enable表示在 markdown 文档开头添加 Front Matter frontMatter.include表示只输出数组中存在的字段，数据库的其他字段忽略 formatExt=./format-image.js表示将使用自定义文档插件，插件路径为项目根目录下的format-image.js文件 format-image.js 该文档插件的作用就是将 notion 文档最上面的封面图 cover，也下载到本地，并替换为本地图片链接 1234567891011121314151617181920212223242526const &#123; matterMarkdownAdapter &#125; = require(&#x27;@elog/cli&#x27;)/** * 自定义文档插件 * @param &#123;DocDetail&#125; doc doc的类型定义为 DocDetail * @param &#123;ImageClient&#125; imageClient 图床下载器 * @return &#123;Promise&lt;DocDetail&gt;&#125; 返回处理后的文档对象 */const format = async (doc, imageClient) =&gt; &#123; const cover = doc.properties.cover if (imageClient) &#123; // 只有启用图床平台image.enable=true时，imageClient才能用，否则请自行实现图片上传 const url = await imageClient.uploadImageFromUrl(cover, doc) // cover链接替换为本地图片 doc.properties.cover = url &#125; // 将文档内容格式化为带有 Front Matter 的 markdown doc.body = matterMarkdownAdapter(doc); // 返回整个文档对象 return doc;&#125;;module.exports = &#123; // 必须要暴露此方法 format,&#125;; 图床配置 1234local: &#123; outputDir: &#x27;./source/images&#x27;, prefixKey: &#x27;/images&#x27;&#125; outputDir表示图片的存放位置为项目根目录下的source/images文件夹中 prefixKey=/images表示图片的统一前缀为/images，因为 Hexo 会将source/images文件夹视为静态资源根目录，统一将图片放在这里，并指定图片前缀，Hexo 才能找到此图片 更多 Elog 配置详情，请阅读 Elog 文档","categories":[{"name":"Blog","slug":"Blog","permalink":"https://jiahaofang.github.io/categories/Blog/"}],"tags":[{"name":"notion","slug":"notion","permalink":"https://jiahaofang.github.io/tags/notion/"},{"name":"elog","slug":"elog","permalink":"https://jiahaofang.github.io/tags/elog/"}]},{"title":"Notion + Hexo + GitHub Actions + Vercel 博客解决方案","slug":"Notion + Hexo + GitHub Actions + Vercel 博客解决方案","date":"2025-03-31T23:35:00.000Z","updated":"2025-04-01T18:06:00.000Z","comments":true,"path":"/notion-hexo/","link":"","permalink":"https://jiahaofang.github.io/notion-hexo/","excerpt":"博客工具","text":"博客工具 写作平台：Notion 博客平台：Hexo 博客主题：Butterfly@4.10.0 博客文档同步：Elog 部署平台：Vercel 博客仓库：https://github.com/LetTTGACO/notion-hexo 博客搭建指南 Fork模板仓库 点击 Fork 该模板仓库到个人 Github 账号仓库下并 clone 到本地 安装依赖 在项目根目录下运行命令安装依赖 1npm install 新建 Elog 本地调试文件 在项目根目录中复制.elog.example.env文件并改名为.elog.env，此文件将用于本地同步Notion 文档 配置 Notion 关键信息 按照文档提示配置 Notion 并获取 token 和 databaseId，在本地.elog.env中写入 text12NOTION_TOKEN=获取的tokenNOTION_DATABASE_ID=获取的databaseId 本地调试 在项目根目录运行同步命令 1npm run sync:local 启动 Hexo 在项目根目录运行hexo启动命令，会自动打开本地博客 1npm run server 配置 Hexo 博客 根据 Hexo 文档和 Butterfly 主题配置文档，配置你的博客直到你满意为主，你也可以换别的主题，这里不做演示 提交代码到 github 本地访问没问题直接提交所有文件到 Github 仓库即可 部署到 Vercel 注册 Vercel 账号并绑定 Github，在 Vercel 导入 该项目，Vercel 会自动识别出该 Hexo 项目，不需要改动，直接选择 Deploy 部署。部署完成会有一个 Vercel 临时域名，你也可以绑定自己的域名。 配置 Github Actions 权限 在 Github 仓库的设置中找到 Actions-General，打开流水线写入权限Workflow permissions 配置环境变量 在本地运行时，用的是.elog.env文件中定义的 Notion 账号信息，而在 Github Actions 时，需要提前配置环境变量。 在 Github 仓库的设置中找到 Secrets and variables，新增仓库的环境变量NOTION_DATABASE_ID和NOTION_TOKEN和.elog.env保持一致即可 自动化部署 当在 Notion 中改动文档后，手动/自动触发 Github Actions流水线，会重新从 Notion 增量拉取文档，自动提交代码到 Github 仓库。 Vercel 会实时监测仓库代码，当有新的提交时都会重新部署博客。如此就实现了自动化部署博客。 整个流程的关键点就在于：如何手动/自动触发 Github Actions 在项目.github/workflows/sync.yaml中已经配置了外部 API 触发 Github Actions 事件，所以只需要调用 API 触发流水线即可。 手动触发 为了方便，这里提供一个部署在 Vercel 的免费公用的ServerlessAPI，只需要配置好 URL 参数并浏览器访问即可触发流水线 1https://serverless-api-elog.vercel.app/api/github?user=xxx&amp;repo=xxx&amp;event_type=deploy&amp;token=xxx 自动触发 可在 Notion 中结合 Slack 触发，参考教程，这里就不做进一步演示了 自定义 Elog 配置 如果想自定义 Elog 配置，可访问 Elog 文档 博客示例 示例仓库：https://github.com/LetTTGACO/notion-hexo 博客示例地址：https://notion-hexo.vercel.app","categories":[{"name":"Blog","slug":"Blog","permalink":"https://jiahaofang.github.io/categories/Blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://jiahaofang.github.io/tags/hexo/"},{"name":"notion","slug":"notion","permalink":"https://jiahaofang.github.io/tags/notion/"},{"name":"elog","slug":"elog","permalink":"https://jiahaofang.github.io/tags/elog/"}]},{"title":"Notion示例文章","slug":"Notion示例文章","date":"2025-03-31T23:35:00.000Z","updated":"2025-04-01T18:05:00.000Z","comments":true,"path":"/notion-example/","link":"","permalink":"https://jiahaofang.github.io/notion-example/","excerpt":"Notion-Markdown","text":"Notion-Markdown Notion示例文章源地址 行内样式 加粗 斜体 下划线 删除线 行内代码 const a = 123 行内公式，在Vitepress会报错，不做演示 红色的文字 蓝色的文字背景 绿色的块背景 Basic block（基本块） Notion示例文章的子页面 Notion示例文章的子页面 表格标题 备注 测试1 啊大大 测试2 const a = 123 无序列表 有序列表：事物按规律变化，也有一种不可避免的性质．这种性质就叫做必然性 事物的必然性，是事物本身的性质（我们反对宿命论的是其认为这一切是受神明的支配，而不是反对事物发展中存在的不可避免的性质的事实） 第三级别列表 第三级别列表 其决定于它自己本身发展的情况和周围的条件 第三级别列表 第三级别列表 折叠块：点击展开【一级】 点击展开【二级】 点击展开【三级】 内容文本 123 引用块 引用换行 引用换行 引用 2 引用 2 换行 👏 标注文本：Elog 0.4.0-beta.7 发布了！ 开放式跨平台博客解决方案，随意组合写作平台和部署平台 帮助导航👇 ❓ Elog能干什么 🚀 快速开始 Media（媒体） bookmark 46_1677164223.mp4 12345pwd=&#x27;123456&#x27;print(f&quot;password=&#123;pwd!r&#125;&quot;)## output:#password=&#x27;123456&#x27; example.txt DataBase（数据库） 数据库 AI block API不支持，会报错Block type ai_block is not supported via the API. Advanced block（高级块） f([1+{x,y}(xy+yx)(u+1)+a]3/2)(行标)f\\left(\\left[\\frac{1+\\{x, y\\}}{\\left(\\frac{x}{y}+\\frac{y}{x}\\right)(u+1)}+a\\right]^{3 / 2}\\right)\\tag{行标} f⎝⎜⎛​⎣⎡​(yx​+xy​)(u+1)1+{x,y}​+a⎦⎤​3/2⎠⎟⎞​(行标) Notion示例文章的同步块 折叠一级标题 ## 折叠二级标题 折叠内容 两列分栏（左） [ ] 左侧书写 两列分栏（右） [ ] 右侧书写 123graph LR;Mermaid思维导图--&gt;思维导图Mermaid思维导图--&gt;研发 @Anonymous Untitled 2023-04-26 🚀🔥🐸 Embeds（嵌入） 嵌入网页 embed","categories":[{"name":"Blog","slug":"Blog","permalink":"https://jiahaofang.github.io/categories/Blog/"}],"tags":[{"name":"notion","slug":"notion","permalink":"https://jiahaofang.github.io/tags/notion/"}]}],"categories":[{"name":"Coding","slug":"Coding","permalink":"https://jiahaofang.github.io/categories/Coding/"},{"name":"Blog","slug":"Blog","permalink":"https://jiahaofang.github.io/categories/Blog/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://jiahaofang.github.io/tags/iOS/"},{"name":"hexo","slug":"hexo","permalink":"https://jiahaofang.github.io/tags/hexo/"},{"name":"notion","slug":"notion","permalink":"https://jiahaofang.github.io/tags/notion/"},{"name":"elog","slug":"elog","permalink":"https://jiahaofang.github.io/tags/elog/"}]}